declare const NetworkToIndexerAPI: Record<string, string>;
declare const NetworkToNodeAPI: Record<string, string>;
declare const NetworkToFaucetAPI: Record<string, string>;
declare const NetworkToPepperAPI: Record<string, string>;
declare const NetworkToProverAPI: Record<string, string>;
declare enum Network {
    MAINNET = "mainnet",
    TESTNET = "testnet",
    DEVNET = "devnet",
    LOCAL = "local",
    CUSTOM = "custom"
}
declare const NetworkToChainId: Record<string, number>;
declare const NetworkToNetworkName: Record<string, Network>;

type GetAccountCoinsDataQuery = {
    current_fungible_asset_balances: Array<{
        amount?: any | null;
        asset_type?: string | null;
        is_frozen: boolean;
        is_primary?: boolean | null;
        last_transaction_timestamp?: any | null;
        last_transaction_version?: any | null;
        owner_address: string;
        storage_id: string;
        token_standard?: string | null;
        metadata?: {
            token_standard: string;
            symbol: string;
            supply_aggregator_table_key_v1?: string | null;
            supply_aggregator_table_handle_v1?: string | null;
            project_uri?: string | null;
            name: string;
            last_transaction_version: any;
            last_transaction_timestamp: any;
            icon_uri?: string | null;
            decimals: number;
            creator_address: string;
            asset_type: string;
        } | null;
    }>;
};
type GetAccountCollectionsWithOwnedTokensQuery = {
    current_collection_ownership_v2_view: Array<{
        collection_id?: string | null;
        collection_name?: string | null;
        collection_uri?: string | null;
        creator_address?: string | null;
        distinct_tokens?: any | null;
        last_transaction_version?: any | null;
        owner_address?: string | null;
        single_token_uri?: string | null;
        current_collection?: {
            collection_id: string;
            collection_name: string;
            creator_address: string;
            current_supply: any;
            description: string;
            last_transaction_timestamp: any;
            last_transaction_version: any;
            mutable_description?: boolean | null;
            max_supply?: any | null;
            mutable_uri?: boolean | null;
            table_handle_v1?: string | null;
            token_standard: string;
            total_minted_v2?: any | null;
            uri: string;
        } | null;
    }>;
};
type GetAccountOwnedTokensQuery = {
    current_token_ownerships_v2: Array<{
        token_standard: string;
        token_properties_mutated_v1?: any | null;
        token_data_id: string;
        table_type_v1?: string | null;
        storage_id: string;
        property_version_v1: any;
        owner_address: string;
        last_transaction_version: any;
        last_transaction_timestamp: any;
        is_soulbound_v2?: boolean | null;
        is_fungible_v2?: boolean | null;
        amount: any;
        current_token_data?: {
            collection_id: string;
            description: string;
            is_fungible_v2?: boolean | null;
            largest_property_version_v1?: any | null;
            last_transaction_timestamp: any;
            last_transaction_version: any;
            maximum?: any | null;
            supply?: any | null;
            token_data_id: string;
            token_name: string;
            token_properties: any;
            token_standard: string;
            token_uri: string;
            decimals?: any | null;
            current_collection?: {
                collection_id: string;
                collection_name: string;
                creator_address: string;
                current_supply: any;
                description: string;
                last_transaction_timestamp: any;
                last_transaction_version: any;
                max_supply?: any | null;
                mutable_description?: boolean | null;
                mutable_uri?: boolean | null;
                table_handle_v1?: string | null;
                token_standard: string;
                total_minted_v2?: any | null;
                uri: string;
            } | null;
        } | null;
    }>;
};
type GetAccountOwnedTokensFromCollectionQuery = {
    current_token_ownerships_v2: Array<{
        token_standard: string;
        token_properties_mutated_v1?: any | null;
        token_data_id: string;
        table_type_v1?: string | null;
        storage_id: string;
        property_version_v1: any;
        owner_address: string;
        last_transaction_version: any;
        last_transaction_timestamp: any;
        is_soulbound_v2?: boolean | null;
        is_fungible_v2?: boolean | null;
        amount: any;
        current_token_data?: {
            collection_id: string;
            description: string;
            is_fungible_v2?: boolean | null;
            largest_property_version_v1?: any | null;
            last_transaction_timestamp: any;
            last_transaction_version: any;
            maximum?: any | null;
            supply?: any | null;
            token_data_id: string;
            token_name: string;
            token_properties: any;
            token_standard: string;
            token_uri: string;
            decimals?: any | null;
            current_collection?: {
                collection_id: string;
                collection_name: string;
                creator_address: string;
                current_supply: any;
                description: string;
                last_transaction_timestamp: any;
                last_transaction_version: any;
                max_supply?: any | null;
                mutable_description?: boolean | null;
                mutable_uri?: boolean | null;
                table_handle_v1?: string | null;
                token_standard: string;
                total_minted_v2?: any | null;
                uri: string;
            } | null;
        } | null;
    }>;
};
type GetChainTopUserTransactionsQuery = {
    user_transactions: Array<{
        version: any;
    }>;
};
type GetCollectionDataQuery = {
    current_collections_v2: Array<{
        uri: string;
        total_minted_v2?: any | null;
        token_standard: string;
        table_handle_v1?: string | null;
        mutable_uri?: boolean | null;
        mutable_description?: boolean | null;
        max_supply?: any | null;
        collection_id: string;
        collection_name: string;
        creator_address: string;
        current_supply: any;
        description: string;
        last_transaction_timestamp: any;
        last_transaction_version: any;
        cdn_asset_uris?: {
            cdn_image_uri?: string | null;
            asset_uri: string;
            animation_optimizer_retry_count: number;
            cdn_animation_uri?: string | null;
            cdn_json_uri?: string | null;
            image_optimizer_retry_count: number;
            json_parser_retry_count: number;
            raw_animation_uri?: string | null;
            raw_image_uri?: string | null;
        } | null;
    }>;
};
type GetCurrentFungibleAssetBalancesQuery = {
    current_fungible_asset_balances: Array<{
        amount?: any | null;
        asset_type?: string | null;
        is_frozen: boolean;
        is_primary?: boolean | null;
        last_transaction_timestamp?: any | null;
        last_transaction_version?: any | null;
        owner_address: string;
        storage_id: string;
        token_standard?: string | null;
    }>;
};
type GetDelegatedStakingActivitiesQuery = {
    delegated_staking_activities: Array<{
        amount: any;
        delegator_address: string;
        event_index: any;
        event_type: string;
        pool_address: string;
        transaction_version: any;
    }>;
};
type GetEventsQuery = {
    events: Array<{
        account_address: string;
        creation_number: any;
        data: any;
        event_index: any;
        sequence_number: any;
        transaction_block_height: any;
        transaction_version: any;
        type: string;
        indexed_type: string;
    }>;
};
type GetFungibleAssetActivitiesQuery = {
    fungible_asset_activities: Array<{
        amount?: any | null;
        asset_type?: string | null;
        block_height: any;
        entry_function_id_str?: string | null;
        event_index: any;
        gas_fee_payer_address?: string | null;
        is_frozen?: boolean | null;
        is_gas_fee: boolean;
        is_transaction_success: boolean;
        owner_address?: string | null;
        storage_id: string;
        storage_refund_amount: any;
        token_standard: string;
        transaction_timestamp: any;
        transaction_version: any;
        type: string;
    }>;
};
type GetFungibleAssetMetadataQuery = {
    fungible_asset_metadata: Array<{
        icon_uri?: string | null;
        project_uri?: string | null;
        supply_aggregator_table_handle_v1?: string | null;
        supply_aggregator_table_key_v1?: string | null;
        creator_address: string;
        asset_type: string;
        decimals: number;
        last_transaction_timestamp: any;
        last_transaction_version: any;
        name: string;
        symbol: string;
        token_standard: string;
        supply_v2?: any | null;
        maximum_v2?: any | null;
    }>;
};
type GetNamesQuery = {
    current_aptos_names: Array<{
        domain?: string | null;
        expiration_timestamp?: any | null;
        registered_address?: string | null;
        subdomain?: string | null;
        token_standard?: string | null;
        is_primary?: boolean | null;
        owner_address?: string | null;
        subdomain_expiration_policy?: any | null;
        domain_expiration_timestamp?: any | null;
    }>;
};
type GetNumberOfDelegatorsQuery = {
    num_active_delegator_per_pool: Array<{
        num_active_delegator?: any | null;
        pool_address?: string | null;
    }>;
};
type GetObjectDataQuery = {
    current_objects: Array<{
        allow_ungated_transfer: boolean;
        state_key_hash: string;
        owner_address: string;
        object_address: string;
        last_transaction_version: any;
        last_guid_creation_num: any;
        is_deleted: boolean;
    }>;
};
type GetProcessorStatusQuery = {
    processor_status: Array<{
        last_success_version: any;
        processor: string;
        last_updated: any;
    }>;
};
type GetTableItemsDataQuery = {
    table_items: Array<{
        decoded_key: any;
        decoded_value?: any | null;
        key: string;
        table_handle: string;
        transaction_version: any;
        write_set_change_index: any;
    }>;
};
type GetTableItemsMetadataQuery = {
    table_metadatas: Array<{
        handle: string;
        key_type: string;
        value_type: string;
    }>;
};
type GetTokenActivityQuery = {
    token_activities_v2: Array<{
        after_value?: string | null;
        before_value?: string | null;
        entry_function_id_str?: string | null;
        event_account_address: string;
        event_index: any;
        from_address?: string | null;
        is_fungible_v2?: boolean | null;
        property_version_v1: any;
        to_address?: string | null;
        token_amount: any;
        token_data_id: string;
        token_standard: string;
        transaction_timestamp: any;
        transaction_version: any;
        type: string;
    }>;
};
type GetCurrentTokenOwnershipQuery = {
    current_token_ownerships_v2: Array<{
        token_standard: string;
        token_properties_mutated_v1?: any | null;
        token_data_id: string;
        table_type_v1?: string | null;
        storage_id: string;
        property_version_v1: any;
        owner_address: string;
        last_transaction_version: any;
        last_transaction_timestamp: any;
        is_soulbound_v2?: boolean | null;
        is_fungible_v2?: boolean | null;
        amount: any;
        current_token_data?: {
            collection_id: string;
            description: string;
            is_fungible_v2?: boolean | null;
            largest_property_version_v1?: any | null;
            last_transaction_timestamp: any;
            last_transaction_version: any;
            maximum?: any | null;
            supply?: any | null;
            token_data_id: string;
            token_name: string;
            token_properties: any;
            token_standard: string;
            token_uri: string;
            decimals?: any | null;
            current_collection?: {
                collection_id: string;
                collection_name: string;
                creator_address: string;
                current_supply: any;
                description: string;
                last_transaction_timestamp: any;
                last_transaction_version: any;
                max_supply?: any | null;
                mutable_description?: boolean | null;
                mutable_uri?: boolean | null;
                table_handle_v1?: string | null;
                token_standard: string;
                total_minted_v2?: any | null;
                uri: string;
            } | null;
        } | null;
    }>;
};
type GetTokenDataQuery = {
    current_token_datas_v2: Array<{
        collection_id: string;
        description: string;
        is_fungible_v2?: boolean | null;
        largest_property_version_v1?: any | null;
        last_transaction_timestamp: any;
        last_transaction_version: any;
        maximum?: any | null;
        supply?: any | null;
        token_data_id: string;
        token_name: string;
        token_properties: any;
        token_standard: string;
        token_uri: string;
        decimals?: any | null;
        current_collection?: {
            collection_id: string;
            collection_name: string;
            creator_address: string;
            current_supply: any;
            description: string;
            last_transaction_timestamp: any;
            last_transaction_version: any;
            max_supply?: any | null;
            mutable_description?: boolean | null;
            mutable_uri?: boolean | null;
            table_handle_v1?: string | null;
            token_standard: string;
            total_minted_v2?: any | null;
            uri: string;
        } | null;
    }>;
};

/**
 * GENERATED QUERY TYPES FROM GRAPHQL SCHEMA
 *
 * generated types we generate from graphql schema that match the structure of the
 * response type when querying from Hasura schema.
 *
 * These types are used as the return type when making the actual request (usually
 * under the /internal/ folder)
 */

/**
 * CUSTOM RESPONSE TYPES FOR THE END USER
 *
 * To provide a good dev exp, we build custom types derived from the
 * query types to be the response type the end developer/user will
 * work with.
 *
 * These types are used as the return type when calling a sdk api function
 * that calls the function that queries the server (usually under the /api/ folder)
 */
type GetObjectDataQueryResponse = GetObjectDataQuery["current_objects"];
type GetAccountOwnedTokensQueryResponse = GetAccountOwnedTokensQuery["current_token_ownerships_v2"];
type GetAccountOwnedTokensFromCollectionResponse = GetAccountOwnedTokensFromCollectionQuery["current_token_ownerships_v2"];
type GetAccountCollectionsWithOwnedTokenResponse = GetAccountCollectionsWithOwnedTokensQuery["current_collection_ownership_v2_view"];
type GetAccountCoinsDataResponse = GetAccountCoinsDataQuery["current_fungible_asset_balances"];
type GetChainTopUserTransactionsResponse = GetChainTopUserTransactionsQuery["user_transactions"];
type GetEventsResponse = GetEventsQuery["events"];
type GetNumberOfDelegatorsResponse = GetNumberOfDelegatorsQuery["num_active_delegator_per_pool"];
type GetDelegatedStakingActivitiesResponse = GetDelegatedStakingActivitiesQuery["delegated_staking_activities"];
type GetCollectionDataResponse = GetCollectionDataQuery["current_collections_v2"][0];
type GetTokenDataResponse = GetTokenDataQuery["current_token_datas_v2"][0];
type GetProcessorStatusResponse = GetProcessorStatusQuery["processor_status"];
type GetFungibleAssetMetadataResponse = GetFungibleAssetMetadataQuery["fungible_asset_metadata"];
type GetFungibleAssetActivitiesResponse = GetFungibleAssetActivitiesQuery["fungible_asset_activities"];
type GetCurrentFungibleAssetBalancesResponse = GetCurrentFungibleAssetBalancesQuery["current_fungible_asset_balances"];
type GetTokenActivityResponse = GetTokenActivityQuery["token_activities_v2"];
type GetCurrentTokenOwnershipResponse = GetCurrentTokenOwnershipQuery["current_token_ownerships_v2"][0];
type GetOwnedTokensResponse = GetCurrentTokenOwnershipQuery["current_token_ownerships_v2"];
type GetTableItemsDataResponse = GetTableItemsDataQuery["table_items"];
type GetTableItemsMetadataResponse = GetTableItemsMetadataQuery["table_metadatas"];
type GetANSNameResponse = GetNamesQuery["current_aptos_names"];
/**
 * A generic type that being passed by each function and holds an
 * array of properties we can sort the query by
 */
type OrderBy<T> = Array<{
    [K in keyof T]?: OrderByValue;
}>;
type OrderByValue = "asc" | "asc_nulls_first" | "asc_nulls_last" | "desc" | "desc_nulls_first" | "desc_nulls_last";
/**
 * Refers to the token standard we want to query for
 */
type TokenStandard = "v1" | "v2";
/**
 * The graphql query type to pass into the `queryIndexer` function
 */
type GraphqlQuery = {
    query: string;
    variables?: {};
};

declare enum MimeType {
    /**
     * JSON representation, used for transaction submission and accept type JSON output
     */
    JSON = "application/json",
    /**
     * BCS representation, used for accept type BCS output
     */
    BCS = "application/x-bcs",
    /**
     * BCS representation, used for transaction submission in BCS input
     */
    BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs",
    BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs"
}
/**
 * Hex data as input to a function
 */
type HexInput = string | Uint8Array;
/**
 * TypeTag enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/language_storage.rs#L27}
 */
declare enum TypeTagVariants {
    Bool = 0,
    U8 = 1,
    U64 = 2,
    U128 = 3,
    Address = 4,
    Signer = 5,
    Vector = 6,
    Struct = 7,
    U16 = 8,
    U32 = 9,
    U256 = 10,
    Reference = 254,// This is specifically a placeholder and does not represent a real type
    Generic = 255
}
/**
 * Script transaction arguments enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/transaction_argument.rs#L11}
 */
declare enum ScriptTransactionArgumentVariants {
    U8 = 0,
    U64 = 1,
    U128 = 2,
    Address = 3,
    U8Vector = 4,
    Bool = 5,
    U16 = 6,
    U32 = 7,
    U256 = 8
}
/**
 * Transaction payload enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}
 */
declare enum TransactionPayloadVariants {
    Script = 0,
    EntryFunction = 2,
    Multisig = 3
}
/**
 * Transaction variants enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L440}
 */
declare enum TransactionVariants {
    MultiAgentTransaction = 0,
    FeePayerTransaction = 1
}
/**
 * Transaction Authenticator enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L44}
 */
declare enum TransactionAuthenticatorVariant {
    Ed25519 = 0,
    MultiEd25519 = 1,
    MultiAgent = 2,
    FeePayer = 3,
    SingleSender = 4
}
/**
 * Transaction Authenticator enum as they are represented in Rust
 * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L414}
 */
declare enum AccountAuthenticatorVariant {
    Ed25519 = 0,
    MultiEd25519 = 1,
    SingleKey = 2,
    MultiKey = 3
}
declare enum AnyPublicKeyVariant {
    Ed25519 = 0,
    Secp256k1 = 1,
    Keyless = 3
}
declare enum AnySignatureVariant {
    Ed25519 = 0,
    Secp256k1 = 1,
    Keyless = 3
}
declare enum EphemeralPublicKeyVariant {
    Ed25519 = 0
}
declare enum EphemeralSignatureVariant {
    Ed25519 = 0
}
declare enum EphemeralCertificateVariant {
    ZkProof = 0
}
declare enum ZkpVariant {
    Groth16 = 0
}
/**
 * BCS types
 */
type Uint8 = number;
type Uint16 = number;
type Uint32 = number;
type Uint64 = bigint;
type Uint128 = bigint;
type Uint256 = bigint;
type AnyNumber = number | bigint;
/**
 * Set of configuration options that can be provided when initializing the SDK.
 * The purpose of these options is to configure various aspects of the SDK's
 * behavior and interaction with the Aptos network
 */
type AptosSettings = {
    readonly network?: Network;
    readonly fullnode?: string;
    readonly faucet?: string;
    readonly indexer?: string;
    readonly pepper?: string;
    readonly prover?: string;
    readonly clientConfig?: ClientConfig;
    readonly client?: Client;
    readonly fullnodeConfig?: FullNodeConfig;
    readonly indexerConfig?: IndexerConfig;
    readonly faucetConfig?: FaucetConfig;
};
/**
 *
 * Controls the number of results that are returned and the starting position of those results.
 * @param offset parameter specifies the starting position of the query result within the set of data. Default is 0.
 * @param limit specifies the maximum number of items or records to return in a query result. Default is 25.
 */
interface PaginationArgs {
    offset?: AnyNumber;
    limit?: number;
}
interface TokenStandardArg {
    tokenStandard?: TokenStandard;
}
interface OrderByArg<T extends {}> {
    orderBy?: OrderBy<T>;
}
interface WhereArg<T extends {}> {
    where?: T;
}
/**
 * QUERY TYPES
 */
/**
 * A configuration object we can pass with the request to the server.
 *
 * @param API_KEY - api key generated from developer portal {@link https://developers.aptoslabs.com/manage/api-keys}}
 * @param HEADERS - extra headers we want to send with the request
 * @param WITH_CREDENTIALS - whether to carry cookies. By default, it is set to true and cookies will be sent
 */
type ClientConfig = ClientHeadersType & {
    WITH_CREDENTIALS?: boolean;
    API_KEY?: string;
};
/**
 * A Fullnode only configuration object
 *
 * @param HEADERS - extra headers we want to send with the request
 */
type FullNodeConfig = ClientHeadersType;
/**
 * An Indexer only configuration object
 *
 * @param HEADERS - extra headers we want to send with the request
 */
type IndexerConfig = ClientHeadersType;
/**
 * A Faucet only configuration object
 *
 * @param HEADERS - extra headers we want to send with the request
 * @param AUTH_TOKEN - an auth token to send with a faucet request
 */
type FaucetConfig = ClientHeadersType & {
    AUTH_TOKEN?: string;
};
/**
 * General type definition for client HEADERS
 */
type ClientHeadersType = {
    HEADERS?: Record<string, string | number | boolean>;
};
interface ClientRequest<Req> {
    url: string;
    method: "GET" | "POST";
    originMethod?: string;
    body?: Req;
    contentType?: string;
    params?: any;
    overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;
    headers?: Record<string, any>;
}
interface ClientResponse<Res> {
    status: number;
    statusText: string;
    data: Res;
    config?: any;
    request?: any;
    response?: any;
    headers?: any;
}
interface Client {
    provider<Req, Res>(requestOptions: ClientRequest<Req>): Promise<ClientResponse<Res>>;
}
/**
 * The API request type
 *
 * @param url - the url to make the request to, i.e https://fullnode.devnet.aptoslabs.com/v1
 * @param method - the request method "GET" | "POST"
 * @param endpoint (optional) - the endpoint to make the request to, i.e transactions
 * @param body (optional) - the body of the request
 * @param contentType (optional) - the content type to set the `content-type` header to,
 * by default is set to `application/json`
 * @param params (optional) - query params to add to the request
 * @param originMethod (optional) - the local method the request came from
 * @param overrides (optional) - a `ClientConfig` object type to override request data
 */
type AptosRequest = {
    url: string;
    method: "GET" | "POST";
    path?: string;
    body?: any;
    contentType?: string;
    acceptType?: string;
    params?: Record<string, string | AnyNumber | boolean | undefined>;
    originMethod?: string;
    overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;
};
/**
 * Specifies ledger version of transactions. By default latest version will be used
 */
type LedgerVersionArg = {
    ledgerVersion?: AnyNumber;
};
/**
 * RESPONSE TYPES
 */
/**
 * Type holding the outputs of the estimate gas API
 */
type GasEstimation = {
    /**
     * The deprioritized estimate for the gas unit price
     */
    deprioritized_gas_estimate?: number;
    /**
     * The current estimate for the gas unit price
     */
    gas_estimate: number;
    /**
     * The prioritized estimate for the gas unit price
     */
    prioritized_gas_estimate?: number;
};
type MoveResource<T = {}> = {
    type: MoveStructId;
    data: T;
};
type AccountData = {
    sequence_number: string;
    authentication_key: string;
};
type MoveModuleBytecode = {
    bytecode: string;
    abi?: MoveModule;
};
/**
 * TRANSACTION TYPES
 */
declare enum TransactionResponseType {
    Pending = "pending_transaction",
    User = "user_transaction",
    Genesis = "genesis_transaction",
    BlockMetadata = "block_metadata_transaction",
    StateCheckpoint = "state_checkpoint_transaction",
    Validator = "validator_transaction",
    BlockEpilogue = "block_epilogue_transaction"
}
type TransactionResponse = PendingTransactionResponse | CommittedTransactionResponse;
type CommittedTransactionResponse = UserTransactionResponse | GenesisTransactionResponse | BlockMetadataTransactionResponse | StateCheckpointTransactionResponse | ValidatorTransactionResponse | BlockEpilogueTransactionResponse;
declare function isPendingTransactionResponse(response: TransactionResponse): response is PendingTransactionResponse;
declare function isUserTransactionResponse(response: TransactionResponse): response is UserTransactionResponse;
declare function isGenesisTransactionResponse(response: TransactionResponse): response is GenesisTransactionResponse;
declare function isBlockMetadataTransactionResponse(response: TransactionResponse): response is BlockMetadataTransactionResponse;
declare function isStateCheckpointTransactionResponse(response: TransactionResponse): response is StateCheckpointTransactionResponse;
declare function isValidatorTransactionResponse(response: TransactionResponse): response is ValidatorTransactionResponse;
declare function isBlockEpilogueTransactionResponse(response: TransactionResponse): response is BlockEpilogueTransactionResponse;
type PendingTransactionResponse = {
    type: TransactionResponseType.Pending;
    hash: string;
    sender: string;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: TransactionPayloadResponse;
    signature?: TransactionSignature;
};
type UserTransactionResponse = {
    type: TransactionResponseType.User;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    sender: string;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: TransactionPayloadResponse;
    signature?: TransactionSignature;
    /**
     * Events generated by the transaction
     */
    events: Array<Event>;
    timestamp: string;
};
type GenesisTransactionResponse = {
    type: TransactionResponseType.Genesis;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash?: string;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    payload: GenesisPayload;
    /**
     * Events emitted during genesis
     */
    events: Array<Event>;
};
type BlockMetadataTransactionResponse = {
    type: TransactionResponseType.BlockMetadata;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    id: string;
    epoch: string;
    round: string;
    /**
     * The events emitted at the block creation
     */
    events: Array<Event>;
    /**
     * Previous block votes
     */
    previous_block_votes_bitvec: Array<number>;
    proposer: string;
    /**
     * The indices of the proposers who failed to propose
     */
    failed_proposer_indices: Array<number>;
    timestamp: string;
};
type StateCheckpointTransactionResponse = {
    type: TransactionResponseType.StateCheckpoint;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    timestamp: string;
};
type ValidatorTransactionResponse = {
    type: TransactionResponseType.Validator;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    /**
     * The events emitted by the validator transaction
     */
    events: Array<Event>;
    timestamp: string;
};
/**
 * BlockEndInfo describes the gas state of the block
 */
type BlockEndInfo = {
    block_gas_limit_reached: boolean;
    block_output_limit_reached: boolean;
    block_effective_block_gas_units: number;
    block_approx_output_size: number;
};
/**
 * BlockEpilogueTransactionResponse is a transaction that is executed at the end of a block keeping track of data from
 * the whole block
 */
type BlockEpilogueTransactionResponse = {
    type: TransactionResponseType.BlockEpilogue;
    version: string;
    hash: string;
    state_change_hash: string;
    event_root_hash: string;
    state_checkpoint_hash: string | null;
    gas_used: string;
    /**
     * Whether the transaction was successful
     */
    success: boolean;
    /**
     * The VM status of the transaction, can tell useful information in a failure
     */
    vm_status: string;
    accumulator_root_hash: string;
    /**
     * Final state of resources changed by the transaction
     */
    changes: Array<WriteSetChange>;
    timestamp: string;
    block_end_info: BlockEndInfo | null;
};
/**
 * WRITESET CHANGE TYPES
 */
type WriteSetChange = WriteSetChangeDeleteModule | WriteSetChangeDeleteResource | WriteSetChangeDeleteTableItem | WriteSetChangeWriteModule | WriteSetChangeWriteResource | WriteSetChangeWriteTableItem;
type WriteSetChangeDeleteModule = {
    type: string;
    address: string;
    /**
     * State key hash
     */
    state_key_hash: string;
    module: MoveModuleId;
};
type WriteSetChangeDeleteResource = {
    type: string;
    address: string;
    state_key_hash: string;
    resource: string;
};
type WriteSetChangeDeleteTableItem = {
    type: string;
    state_key_hash: string;
    handle: string;
    key: string;
    data?: DeletedTableData;
};
type WriteSetChangeWriteModule = {
    type: string;
    address: string;
    state_key_hash: string;
    data: MoveModuleBytecode;
};
type WriteSetChangeWriteResource = {
    type: string;
    address: string;
    state_key_hash: string;
    data: MoveResource;
};
type WriteSetChangeWriteTableItem = {
    type: string;
    state_key_hash: string;
    handle: string;
    key: string;
    value: string;
    data?: DecodedTableData;
};
type DecodedTableData = {
    /**
     * Key of table in JSON
     */
    key: any;
    /**
     * Type of key
     */
    key_type: string;
    /**
     * Value of table in JSON
     */
    value: any;
    /**
     * Type of value
     */
    value_type: string;
};
/**
 * Deleted table data
 */
type DeletedTableData = {
    /**
     * Deleted key
     */
    key: any;
    /**
     * Deleted key type
     */
    key_type: string;
};
type TransactionPayloadResponse = EntryFunctionPayloadResponse | ScriptPayloadResponse | MultisigPayloadResponse;
type EntryFunctionPayloadResponse = {
    type: string;
    function: MoveFunctionId;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<string>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};
type ScriptPayloadResponse = {
    type: string;
    code: MoveScriptBytecode;
    /**
     * Type arguments of the function
     */
    type_arguments: Array<string>;
    /**
     * Arguments of the function
     */
    arguments: Array<any>;
};
type MultisigPayloadResponse = {
    type: string;
    multisig_address: string;
    transaction_payload?: EntryFunctionPayloadResponse;
};
type GenesisPayload = {
    type: string;
    write_set: WriteSet;
};
/**
 * Move script bytecode
 */
type MoveScriptBytecode = {
    bytecode: string;
    abi?: MoveFunction;
};
/**
 * These are the JSON representations of transaction signatures returned from the node API.
 */
type TransactionSignature = TransactionEd25519Signature | TransactionSecp256k1Signature | TransactionMultiEd25519Signature | TransactionMultiAgentSignature | TransactionFeePayerSignature;
declare function isEd25519Signature(signature: TransactionSignature): signature is TransactionFeePayerSignature;
declare function isSecp256k1Signature(signature: TransactionSignature): signature is TransactionFeePayerSignature;
declare function isMultiAgentSignature(signature: TransactionSignature): signature is TransactionMultiAgentSignature;
declare function isFeePayerSignature(signature: TransactionSignature): signature is TransactionFeePayerSignature;
declare function isMultiEd25519Signature(signature: TransactionSignature): signature is TransactionMultiEd25519Signature;
type TransactionEd25519Signature = {
    type: string;
    public_key: string;
    signature: "ed25519_signature";
};
type TransactionSecp256k1Signature = {
    type: string;
    public_key: string;
    signature: "secp256k1_ecdsa_signature";
};
type TransactionMultiEd25519Signature = {
    type: "multi_ed25519_signature";
    /**
     * The public keys for the Ed25519 signature
     */
    public_keys: Array<string>;
    /**
     * Signature associated with the public keys in the same order
     */
    signatures: Array<string>;
    /**
     * The number of signatures required for a successful transaction
     */
    threshold: number;
    bitmap: string;
};
type TransactionMultiAgentSignature = {
    type: "multi_agent_signature";
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<string>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
};
type TransactionFeePayerSignature = {
    type: "fee_payer_signature";
    sender: AccountSignature;
    /**
     * The other involved parties' addresses
     */
    secondary_signer_addresses: Array<string>;
    /**
     * The associated signatures, in the same order as the secondary addresses
     */
    secondary_signers: Array<AccountSignature>;
    fee_payer_address: string;
    fee_payer_signer: AccountSignature;
};
/**
 * The union of all single account signatures.
 */
type AccountSignature = TransactionEd25519Signature | TransactionSecp256k1Signature | TransactionMultiEd25519Signature;
type WriteSet = ScriptWriteSet | DirectWriteSet;
type ScriptWriteSet = {
    type: string;
    execute_as: string;
    script: ScriptPayloadResponse;
};
type DirectWriteSet = {
    type: string;
    changes: Array<WriteSetChange>;
    events: Array<Event>;
};
type EventGuid = {
    creation_number: string;
    account_address: string;
};
type Event = {
    guid: EventGuid;
    sequence_number: string;
    type: string;
    /**
     * The JSON representation of the event
     */
    data: any;
};
/**
 * Map of Move types to local TypeScript types
 */
type MoveUint8Type = number;
type MoveUint16Type = number;
type MoveUint32Type = number;
type MoveUint64Type = string;
type MoveUint128Type = string;
type MoveUint256Type = string;
type MoveAddressType = string;
type MoveObjectType = string;
type MoveOptionType = MoveType | null | undefined;
/**
 * This is the format for a fully qualified struct, resource, or entry function in Move.
 */
type MoveStructId = `${string}::${string}::${string}`;
type MoveFunctionId = MoveStructId;
type MoveStructType = {};
type MoveType = boolean | string | MoveUint8Type | MoveUint16Type | MoveUint32Type | MoveUint64Type | MoveUint128Type | MoveUint256Type | MoveAddressType | MoveObjectType | MoveStructType | Array<MoveType>;
/**
 * Possible Move values acceptable by move functions (entry, view)
 *
 * Map of a Move value to the corresponding TypeScript value
 *
 * `Bool -> boolean`
 *
 * `u8, u16, u32 -> number`
 *
 * `u64, u128, u256 -> string`
 *
 * `String -> string`
 *
 * `Address -> 0x${string}`
 *
 * `Struct - 0x${string}::${string}::${string}`
 *
 * `Object -> 0x${string}`
 *
 * `Vector -> Array<MoveValue>`
 *
 * `Option -> MoveValue | null | undefined`
 */
type MoveValue = boolean | string | MoveUint8Type | MoveUint16Type | MoveUint32Type | MoveUint64Type | MoveUint128Type | MoveUint256Type | MoveAddressType | MoveObjectType | MoveStructId | MoveOptionType | Array<MoveValue>;
/**
 * Move module id is a string representation of Move module.
 * Module name is case-sensitive.
 */
type MoveModuleId = `${string}::${string}`;
/**
 * Move function visibility
 */
declare enum MoveFunctionVisibility {
    PRIVATE = "private",
    PUBLIC = "public",
    FRIEND = "friend"
}
/**
 * Move function ability
 */
declare enum MoveAbility {
    STORE = "store",
    DROP = "drop",
    KEY = "key",
    COPY = "copy"
}
/**
 * Move abilities tied to the generic type param and associated with the function that uses it
 */
type MoveFunctionGenericTypeParam = {
    constraints: Array<MoveAbility>;
};
/**
 * Move struct field
 */
type MoveStructField = {
    name: string;
    type: string;
};
/**
 * A Move module
 */
type MoveModule = {
    address: string;
    name: string;
    /**
     * Friends of the module
     */
    friends: Array<MoveModuleId>;
    /**
     * Public functions of the module
     */
    exposed_functions: Array<MoveFunction>;
    /**
     * Structs of the module
     */
    structs: Array<MoveStruct>;
};
/**
 * A move struct
 */
type MoveStruct = {
    name: string;
    /**
     * Whether the struct is a native struct of Move
     */
    is_native: boolean;
    /**
     * Abilities associated with the struct
     */
    abilities: Array<MoveAbility>;
    /**
     * Generic types associated with the struct
     */
    generic_type_params: Array<MoveFunctionGenericTypeParam>;
    /**
     * Fields associated with the struct
     */
    fields: Array<MoveStructField>;
};
/**
 * Move function
 */
type MoveFunction = {
    name: string;
    visibility: MoveFunctionVisibility;
    /**
     * Whether the function can be called as an entry function directly in a transaction
     */
    is_entry: boolean;
    /**
     * Whether the function is a view function or not
     */
    is_view: boolean;
    /**
     * Generic type params associated with the Move function
     */
    generic_type_params: Array<MoveFunctionGenericTypeParam>;
    /**
     * Parameters associated with the move function
     */
    params: Array<string>;
    /**
     * Return type of the function
     */
    return: Array<string>;
};
declare enum RoleType {
    VALIDATOR = "validator",
    FULL_NODE = "full_node"
}
type LedgerInfo = {
    /**
     * Chain ID of the current chain
     */
    chain_id: number;
    epoch: string;
    ledger_version: string;
    oldest_ledger_version: string;
    ledger_timestamp: string;
    node_role: RoleType;
    oldest_block_height: string;
    block_height: string;
    /**
     * Git hash of the build of the API endpoint.  Can be used to determine the exact
     * software version used by the API endpoint.
     */
    git_hash?: string;
};
/**
 * A Block type
 */
type Block = {
    block_height: string;
    block_hash: string;
    block_timestamp: string;
    first_version: string;
    last_version: string;
    /**
     * The transactions in the block in sequential order
     */
    transactions?: Array<TransactionResponse>;
};
/**
 * Table Item request for the GetTableItem API
 */
type TableItemRequest = {
    key_type: MoveValue;
    value_type: MoveValue;
    /**
     * The value of the table item's key
     */
    key: any;
};
/**
 * A list of Authentication Key schemes that are supported by Aptos.
 *
 * They are combinations of signing schemes and derive schemes.
 */
type AuthenticationKeyScheme = SigningScheme | DeriveScheme;
declare enum SigningScheme {
    /**
     * For Ed25519PublicKey
     */
    Ed25519 = 0,
    /**
     * For MultiEd25519PublicKey
     */
    MultiEd25519 = 1,
    /**
     * For SingleKey ecdsa
     */
    SingleKey = 2,
    MultiKey = 3
}
declare enum SigningSchemeInput {
    /**
     * For Ed25519PublicKey
     */
    Ed25519 = 0,
    /**
     * For Secp256k1Ecdsa
     */
    Secp256k1Ecdsa = 2
}
/**
 * Scheme used for deriving account addresses from other data
 */
declare enum DeriveScheme {
    /**
     * Derives an address using an AUID, used for objects
     */
    DeriveAuid = 251,
    /**
     * Derives an address from another object address
     */
    DeriveObjectAddressFromObject = 252,
    /**
     * Derives an address from a GUID, used for objects
     */
    DeriveObjectAddressFromGuid = 253,
    /**
     * Derives an address from seed bytes, used for named objects
     */
    DeriveObjectAddressFromSeed = 254,
    /**
     * Derives an address from seed bytes, used for resource accounts
     */
    DeriveResourceAccountAddress = 255
}
/**
 * Option properties to pass for waitForTransaction() function
 */
type WaitForTransactionOptions = {
    timeoutSecs?: number;
    checkSuccess?: boolean;
    waitForIndexer?: boolean;
};
/**
 * Input type to generate an account using Single Signer
 * Ed25519 or Legacy Ed25519
 */
type GenerateAccountWithEd25519 = {
    scheme: SigningSchemeInput.Ed25519;
    legacy: boolean;
};
/**
 * Input type to generate an account using Single Signer
 * Secp256k1
 */
type GenerateAccountWithSingleSignerSecp256k1Key = {
    scheme: SigningSchemeInput.Secp256k1Ecdsa;
    legacy?: false;
};
type GenerateAccount = GenerateAccountWithEd25519 | GenerateAccountWithSingleSignerSecp256k1Key;

/**
 * This interface exists to define Deserializable<T> inputs for functions that
 * deserialize a byte buffer into a type T.
 * It is not intended to be implemented or extended, because Typescript has no support
 * for static methods in interfaces.
 */
interface Deserializable<T> {
    deserialize(deserializer: Deserializer): T;
}
declare class Deserializer {
    private buffer;
    private offset;
    constructor(data: Uint8Array);
    private read;
    /**
     * Returns the number of bytes remaining in the buffer.
     *
     * Useful to tell if there's more data to be read.
     */
    remaining(): number;
    /**
     * Deserializes a string. UTF8 string is supported. Reads the string's bytes length "l" first,
     * and then reads "l" bytes of content. Decodes the byte array into a string.
     *
     * BCS layout for "string": string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     *
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * assert(deserializer.deserializeStr() === "1234abcd");
     * ```
     */
    deserializeStr(): string;
    /**
     * Deserializes a an optional string.
     *
     * BCS layout for Optional<String>: 0 if none, else 1 | string_length | string_content
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x00]));
     * assert(deserializer.deserializeOptionStr() === undefined);
     * const deserializer = new Deserializer(new Uint8Array([1, 8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * assert(deserializer.deserializeOptionStr() === "1234abcd");
     * ```
     */
    deserializeOptionStr(): string | undefined;
    /**
     * Deserializes a an optional deserializable class.
     *
     * BCS layout for Optional<T>: 0 if none, else 1 | bcs representation of class
     *
     * @example
     * const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));
     * const value = deserializer.deserializeOption(MyClass); // where MyClass has a `deserialize` function
     * // value is now an instance of MyClass
     *
     * const deserializer = new Deserializer(new Uint8Array([0]));
     * const value = deserializer.deserializeOption(MyClass); // where MyClass has a `deserialize` function
     * // value is undefined
     *
     * @param cls The BCS-deserializable class to deserialize the buffered bytes into.
     *
     * @returns the deserialized value of class type T
     */
    deserializeOption<T>(cls: Deserializable<T>): T | undefined;
    /**
     * Deserializes an array of bytes.
     *
     * BCS layout for "bytes": bytes_length | bytes
     * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.
     */
    deserializeBytes(): Uint8Array;
    /**
     * Deserializes an array of bytes. The number of bytes to read is already known.
     *
     */
    deserializeFixedBytes(len: number): Uint8Array;
    /**
     * Deserializes a boolean value.
     *
     * BCS layout for "boolean": One byte. "0x01" for true and "0x00" for false.
     */
    deserializeBool(): boolean;
    /**
     * Deserializes a uint8 number.
     *
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     */
    deserializeU8(): Uint8;
    /**
     * Deserializes a uint16 number.
     *
     * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
     * assert(deserializer.deserializeU16() === 4660);
     * ```
     */
    deserializeU16(): Uint16;
    /**
     * Deserializes a uint32 number.
     *
     * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU32() === 305419896);
     * ```
     */
    deserializeU32(): Uint32;
    /**
     * Deserializes a uint64 number.
     *
     * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * assert(deserializer.deserializeU64() === 1311768467750121216);
     * ```
     */
    deserializeU64(): Uint64;
    /**
     * Deserializes a uint128 number.
     *
     * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
     */
    deserializeU128(): Uint128;
    /**
     * Deserializes a uint256 number.
     *
     * BCS layout for "uint256": Thirty-two bytes. Binary format in little-endian representation.
     */
    deserializeU256(): Uint256;
    /**
     * Deserializes a uleb128 encoded uint32 number.
     *
     * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
     */
    deserializeUleb128AsU32(): Uint32;
    /**
     * Helper function that primarily exists to support alternative syntax for deserialization.
     * That is, if we have a `const deserializer: new Deserializer(...)`, instead of having to use
     * `MyClass.deserialize(deserializer)`, we can call `deserializer.deserialize(MyClass)`.
     *
     * @example const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));
     * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function
     * // value is now an instance of MyClass
     * // equivalent to `const value = MyClass.deserialize(deserializer)`
     * @param cls The BCS-deserializable class to deserialize the buffered bytes into.
     *
     * @returns the deserialized value of class type T
     */
    deserialize<T>(cls: Deserializable<T>): T;
    /**
     * Deserializes an array of BCS Deserializable values given an existing Deserializer
     * instance with a loaded byte buffer.
     *
     * @param cls The BCS-deserializable class to deserialize the buffered bytes into.
     * @example
     * // serialize a vector of addresses
     * const addresses = new Array<AccountAddress>(
     *   AccountAddress.from("0x1"),
     *   AccountAddress.from("0x2"),
     *   AccountAddress.from("0xa"),
     *   AccountAddress.from("0xb"),
     * );
     * const serializer = new Serializer();
     * serializer.serializeVector(addresses);
     * const serializedBytes = serializer.toUint8Array();
     *
     * // deserialize the bytes into an array of addresses
     * const deserializer = new Deserializer(serializedBytes);
     * const deserializedAddresses = deserializer.deserializeVector(AccountAddress);
     * // deserializedAddresses is now an array of AccountAddress instances
     * @returns an array of deserialized values of type T
     */
    deserializeVector<T>(cls: Deserializable<T>): Array<T>;
}

/**
 * This error is used to explain why parsing failed.
 */
declare class ParsingError<T> extends Error {
    /**
     * This provides a programmatic way to access why parsing failed. Downstream devs
     * might want to use this to build their own error messages if the default error
     * messages are not suitable for their use case. This should be an enum.
     */
    invalidReason: T;
    constructor(message: string, invalidReason: T);
}
/**
 * Whereas ParsingError is thrown when parsing fails, e.g. in a fromString function,
 * this type is returned from "defensive" functions like isValid.
 */
type ParsingResult<T> = {
    /**
     * True if valid, false otherwise.
     */
    valid: boolean;
    /**
     * If valid is false, this will be a code explaining why parsing failed.
     */
    invalidReason?: T;
    /**
     * If valid is false, this will be a string explaining why parsing failed.
     */
    invalidReasonMessage?: string;
};

/**
 * This enum is used to explain why parsing might have failed.
 */
declare enum HexInvalidReason {
    TOO_SHORT = "too_short",
    INVALID_LENGTH = "invalid_length",
    INVALID_HEX_CHARS = "invalid_hex_chars"
}
/**
 * NOTE: Do not use this class when working with account addresses, use AccountAddress.
 *
 * NOTE: When accepting hex data as input to a function, prefer to accept HexInput and
 * then use the static helper methods of this class to convert it into the desired
 * format. This enables the greatest flexibility for the developer.
 *
 * Hex is a helper class for working with hex data. Hex data, when represented as a
 * string, generally looks like this, for example: 0xaabbcc, 45cd32, etc.
 *
 * You might use this class like this:
 *
 * ```ts
 * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {
 *   const txnHashString = Hex.fromHexInput(txnHash).toString();
 *   return await getTransactionByHashInner(txnHashString);
 * }
 * ```
 *
 * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string
 * with a leading 0x prefix, regardless of what the input format was.
 *
 * These are some other ways to chain the functions together:
 * - `Hex.fromHexString({ hexInput: "0x1f" }).toUint8Array()`
 * - `new Hex([1, 3]).toStringWithoutPrefix()`
 */
declare class Hex {
    private readonly data;
    /**
     * Create a new Hex instance from a Uint8Array.
     *
     * @param data Uint8Array
     */
    constructor(data: Uint8Array);
    /**
     * Get the inner hex data. The inner data is already a Uint8Array so no conversion
     * is taking place here, it just returns the inner data.
     *
     * @returns Hex data as Uint8Array
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the hex data as a string without the 0x prefix.
     *
     * @returns Hex string without 0x prefix
     */
    toStringWithoutPrefix(): string;
    /**
     * Get the hex data as a string with the 0x prefix.
     *
     * @returns Hex string with 0x prefix
     */
    toString(): string;
    /**
     * Static method to convert a hex string to Hex
     *
     * @param str A hex string, with or without the 0x prefix
     *
     * @returns Hex
     */
    static fromHexString(str: string): Hex;
    /**
     * Static method to convert an instance of HexInput to Hex
     *
     * @param hexInput A HexInput (string or Uint8Array)
     *
     * @returns Hex
     */
    static fromHexInput(hexInput: HexInput): Hex;
    /**
     * Check if the string is valid hex.
     *
     * @param str A hex string representing byte data.
     *
     * @returns valid = true if the string is valid, false if not. If the string is not
     * valid, invalidReason and invalidReasonMessage will be set explaining why it is
     * invalid.
     */
    static isValid(str: string): ParsingResult<HexInvalidReason>;
    /**
     * Return whether Hex instances are equal. Hex instances are considered equal if
     * their underlying byte data is identical.
     *
     * @param other The Hex instance to compare to.
     * @returns true if the Hex instances are equal, false if not.
     */
    equals(other: Hex): boolean;
}

declare abstract class Serializable {
    abstract serialize(serializer: Serializer): void;
    /**
     * Serializes a `Serializable` value to its BCS representation.
     * This function is the Typescript SDK equivalent of `bcs::to_bytes` in Move.
     * @returns the BCS representation of the Serializable instance as a byte buffer
     */
    bcsToBytes(): Uint8Array;
    /**
     * Helper function to get a value's BCS-serialized bytes as a Hex instance.
     * @returns a Hex instance with the BCS-serialized bytes loaded into its underlying Uint8Array
     */
    bcsToHex(): Hex;
}
declare class Serializer {
    private buffer;
    private offset;
    constructor(length?: number);
    private ensureBufferWillHandleSize;
    protected appendToBuffer(values: Uint8Array): void;
    private serializeWithFunction;
    /**
     * Serializes a string. UTF8 string is supported.
     *
     * The number of bytes in the string content is serialized first, as a uleb128-encoded u32 integer.
     * Then the string content is serialized as UTF8 encoded bytes.
     *
     * BCS layout for "string": string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     *
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeStr("1234abcd");
     * assert(serializer.toUint8Array() === new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));
     * ```
     */
    serializeStr(value: string): void;
    /**
     * Serializes an array of bytes.
     *
     * BCS layout for "bytes": bytes_length | bytes
     * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.
     */
    serializeBytes(value: Uint8Array): void;
    /**
     * Serializes an array of bytes with known length. Therefore, length doesn't need to be
     * serialized to help deserialization.
     *
     * When deserializing, the number of bytes to deserialize needs to be passed in.
     */
    serializeFixedBytes(value: Uint8Array): void;
    /**
     * Serializes a boolean value.
     *
     * BCS layout for "boolean": One byte. "0x01" for true and "0x00" for false.
     */
    serializeBool(value: boolean): void;
    /**
     * Serializes a uint8 number.
     *
     * BCS layout for "uint8": One byte. Binary format in little-endian representation.
     */
    serializeU8(value: Uint8): void;
    /**
     * Serializes a uint16 number.
     *
     * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU16(4660);
     * assert(serializer.toUint8Array() === new Uint8Array([0x34, 0x12]));
     * ```
     */
    serializeU16(value: Uint16): void;
    /**
     * Serializes a uint32 number.
     *
     * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU32(305419896);
     * assert(serializer.toUint8Array() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));
     * ```
     */
    serializeU32(value: Uint32): void;
    /**
     * Serializes a uint64 number.
     *
     * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeU64(1311768467750121216);
     * assert(serializer.toUint8Array() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
     * ```
     */
    serializeU64(value: AnyNumber): void;
    /**
     * Serializes a uint128 number.
     *
     * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
     */
    serializeU128(value: AnyNumber): void;
    /**
     * Serializes a uint256 number.
     *
     * BCS layout for "uint256": Sixteen bytes. Binary format in little-endian representation.
     */
    serializeU256(value: AnyNumber): void;
    /**
     * Serializes a uint32 number with uleb128.
     *
     * BCS uses uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
     */
    serializeU32AsUleb128(val: Uint32): void;
    /**
     * Returns the buffered bytes
     */
    toUint8Array(): Uint8Array;
    /**
     * Serializes a `Serializable` value, facilitating composable serialization.
     *
     * @param value The Serializable value to serialize
     *
     * @example
     * // Define the MoveStruct class that implements the Serializable interface
     * class MoveStruct extends Serializable {
     *     constructor(
     *         public creatorAddress: AccountAddress, // where AccountAddress extends Serializable
     *         public collectionName: string,
     *         public tokenName: string
     *     ) {}
     *
     *     serialize(serializer: Serializer): void {
     *         serializer.serialize(this.creatorAddress);  // Composable serialization of another Serializable object
     *         serializer.serializeStr(this.collectionName);
     *         serializer.serializeStr(this.tokenName);
     *     }
     * }
     *
     * // Construct a MoveStruct
     * const moveStruct = new MoveStruct(new AccountAddress(...), "MyCollection", "TokenA");
     *
     * // Serialize a string, a u64 number, and a MoveStruct instance.
     * const serializer = new Serializer();
     * serializer.serializeStr("ExampleString");
     * serializer.serializeU64(12345678);
     * serializer.serialize(moveStruct);
     *
     * // Get the bytes from the Serializer instance
     * const serializedBytes = serializer.toUint8Array();
     *
     * @returns the serializer instance
     */
    serialize<T extends Serializable>(value: T): void;
    /**
     * Serializes an array of BCS Serializable values to a serializer instance.
     * Note that this does not return anything. The bytes are added to the serializer instance's byte buffer.
     *
     * @param values The array of BCS Serializable values
     * @example
     * const addresses = new Array<AccountAddress>(
     *   AccountAddress.from("0x1"),
     *   AccountAddress.from("0x2"),
     *   AccountAddress.from("0xa"),
     *   AccountAddress.from("0xb"),
     * );
     * const serializer = new Serializer();
     * serializer.serializeVector(addresses);
     * const serializedBytes = serializer.toUint8Array();
     * // serializedBytes is now the BCS-serialized bytes
     * // The equivalent value in Move would be:
     * // `bcs::to_bytes(&vector<address> [@0x1, @0x2, @0xa, @0xb])`;
     */
    serializeVector<T extends Serializable>(values: Array<T>): void;
    /**
     * Serializes a BCS Serializable values into a serializer instance or undefined.
     * Note that this does not return anything. The bytes are added to the serializer instance's byte buffer.
     *
     * @param values The array of BCS Serializable values
     *
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeOption(new AccountAddress(...));
     * const serializedBytes = serializer.toUint8Array();
     * // serializedBytes is now the BCS-serialized byte representation of AccountAddress
     *
     * const serializer = new Serializer();
     * serializer.serializeOption(undefined);
     * assert(serializer.toUint8Array() === new Uint8Array([0x00]));
     * ```
     */
    serializeOption<T extends Serializable>(value?: T): void;
    /**
     * Serializes an optional string. UTF8 string is supported.
     *
     * The existence of the string is encoded first, 0 if undefined and 1 if it exists.
     * Them the number of bytes in the string content is serialized, as a uleb128-encoded u32 integer.
     * Then the string content is serialized as UTF8 encoded bytes.
     *
     * BCS layout for optional "string": 1 | string_length | string_content
     * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.
     *
     * BCS layout for undefined: 0
     * @example
     * ```ts
     * const serializer = new Serializer();
     * serializer.serializeOptionStr("1234abcd");
     * assert(serializer.toUint8Array() === new Uint8Array([1, 8, 49, 50, 51, 52, 97, 98, 99, 100]));
     *
     * const serializer = new Serializer();
     * serializer.serializeOptionStr(undefined);
     * assert(serializer.toUint8Array() === new Uint8Array([0]));
     * ```
     */
    serializeOptionStr(value?: string): void;
}
declare function ensureBoolean(value: unknown): asserts value is boolean;
declare const outOfRangeErrorMessage: (value: AnyNumber, min: AnyNumber, max: AnyNumber) => string;
declare function validateNumberInRange<T extends AnyNumber>(value: T, minValue: T, maxValue: T): void;

interface TransactionArgument extends EntryFunctionArgument, ScriptFunctionArgument {
}
interface EntryFunctionArgument {
    /**
     * Serialize an argument to BCS-serialized bytes.
     */
    serialize(serializer: Serializer): void;
    /**
     * Serialize an argument as a type-agnostic, fixed byte sequence. The byte sequence contains
     * the number of the following bytes followed by the BCS-serialized bytes for a typed argument.
     */
    serializeForEntryFunction(serializer: Serializer): void;
    bcsToBytes(): Uint8Array;
    bcsToHex(): Hex;
}
interface ScriptFunctionArgument {
    /**
     * Serialize an argument to BCS-serialized bytes.
     */
    serialize(serializer: Serializer): void;
    /**
     * Serialize an argument to BCS-serialized bytes as a type aware byte sequence.
     * The byte sequence contains an enum variant index followed by the BCS-serialized
     * bytes for a typed argument.
     */
    serializeForScriptFunction(serializer: Serializer): void;
    bcsToBytes(): Uint8Array;
    bcsToHex(): Hex;
}

/**
 * This enum is used to explain why an address was invalid.
 */
declare enum AddressInvalidReason {
    INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes",
    INVALID_HEX_CHARS = "invalid_hex_chars",
    TOO_SHORT = "too_short",
    TOO_LONG = "too_long",
    LEADING_ZERO_X_REQUIRED = "leading_zero_x_required",
    LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special",
    INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES"
}
type AccountAddressInput = HexInput | AccountAddress;
/**
 * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction
 * hashes, use the Hex class.
 *
 * AccountAddress is used for working with account addresses. Account addresses, when
 * represented as a string, generally look like these examples:
 * - 0x1
 * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c
 *
 * Proper formatting and parsing of account addresses is defined by AIP-40.
 * To learn more about the standard, read the AIP here:
 * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
 *
 * The comments in this class make frequent reference to the LONG and SHORT formats,
 * as well as "special" addresses. To learn what these refer to see AIP-40.
 */
declare class AccountAddress extends Serializable implements TransactionArgument {
    /**
     * This is the internal representation of an account address.
     */
    readonly data: Uint8Array;
    /**
     * The number of bytes that make up an account address.
     */
    static readonly LENGTH: number;
    /**
     * The length of an address string in LONG form without a leading 0x.
     */
    static readonly LONG_STRING_LENGTH: number;
    static ZERO: AccountAddress;
    static ONE: AccountAddress;
    static TWO: AccountAddress;
    static THREE: AccountAddress;
    static FOUR: AccountAddress;
    static A: AccountAddress;
    /**
     * Creates an instance of AccountAddress from a Uint8Array.
     *
     * @param args.data A Uint8Array representing an account address.
     */
    constructor(input: Uint8Array);
    /**
     * Returns whether an address is special, where special is defined as 0x0 to 0xf
     * inclusive. In other words, the last byte of the address must be < 0b10000 (16)
     * and every other byte must be zero.
     *
     * For more information on how special addresses are defined see AIP-40:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @returns true if the address is special, false if not.
     */
    isSpecial(): boolean;
    /**
     * Return the AccountAddress as a string as per AIP-40.
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * In short, it means that special addresses are represented in SHORT form, meaning
     * 0x0 through to 0xf inclusive, and every other address is represented in LONG form,
     * meaning 0x + 64 hex characters.
     *
     * @returns AccountAddress as a string conforming to AIP-40.
     */
    toString(): `0x${string}`;
    /**
     * NOTE: Prefer to use `toString` where possible.
     *
     * Return the AccountAddress as a string as per AIP-40 but without the leading 0x.
     *
     * Learn more by reading the docstring of `toString`.
     *
     * @returns AccountAddress as a string conforming to AIP-40 but without the leading 0x.
     */
    toStringWithoutPrefix(): string;
    /**
     * NOTE: Prefer to use `toString` where possible.
     *
     * Whereas toString will format special addresses (as defined by isSpecial) using the
     * SHORT form (no leading 0s), this format the address in the LONG format
     * unconditionally.
     *
     * This means it will be 0x + 64 hex characters.
     *
     * @returns AccountAddress as a string in LONG form.
     */
    toStringLong(): `0x${string}`;
    /**
     * NOTE: Prefer to use `toString` where possible.
     *
     * Whereas toString will format special addresses (as defined by isSpecial) using the
     * SHORT form (no leading 0s), this function will include leading zeroes. The string
     * will not have a leading zero.
     *
     * This means it will be 64 hex characters without a leading 0x.
     *
     * @returns AccountAddress as a string in LONG form without a leading 0x.
     */
    toStringLongWithoutPrefix(): string;
    /**
     * Get the inner hex data. The inner data is already a Uint8Array so no conversion
     * is taking place here, it just returns the inner data.
     *
     * @returns Hex data as Uint8Array
     */
    toUint8Array(): Uint8Array;
    /**
     * Serialize the AccountAddress to a Serializer instance's data buffer.
     * @param serializer The serializer to serialize the AccountAddress to.
     * @returns void
     * @example
     * const serializer = new Serializer();
     * const address = AccountAddress.fromString("0x1");
     * address.serialize(serializer);
     * const bytes = serializer.toUint8Array();
     * // `bytes` is now the BCS-serialized address.
     */
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    /**
     * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.
     * @param deserializer The deserializer to deserialize the AccountAddress from.
     * @returns An instance of AccountAddress.
     * @example
     * const bytes = hexToBytes("0x0102030405060708091011121314151617181920212223242526272829303132");
     * const deserializer = new Deserializer(bytes);
     * const address = AccountAddress.deserialize(deserializer);
     * // `address` is now an instance of AccountAddress.
     */
    static deserialize(deserializer: Deserializer): AccountAddress;
    /**
     * NOTE: This function has strict parsing behavior. For relaxed behavior, please use
     * the `fromString` function.
     *
     * Creates an instance of AccountAddress from a hex string.
     *
     * This function allows only the strictest formats defined by AIP-40. In short this
     * means only the following formats are accepted:
     *
     * - LONG
     * - SHORT for special addresses
     *
     * Where:
     * - LONG is defined as 0x + 64 hex characters.
     * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.
     *
     * This means the following are not accepted:
     * - SHORT for non-special addresses.
     * - Any address without a leading 0x.
     *
     * Learn more about the different address formats by reading AIP-40:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @param input A hex string representing an account address.
     *
     * @returns An instance of AccountAddress.
     */
    static fromStringStrict(input: string): AccountAddress;
    /**
     * NOTE: This function has relaxed parsing behavior. For strict behavior, please use
     * the `fromStringStrict` function. Where possible use `fromStringStrict` rather than this
     * function, `fromString` is only provided for backwards compatibility.
     *
     * Creates an instance of AccountAddress from a hex string.
     *
     * This function allows all formats defined by AIP-40. In short this means the
     * following formats are accepted:
     *
     * - LONG, with or without leading 0x
     * - SHORT, with or without leading 0x
     *
     * Where:
     * - LONG is 64 hex characters.
     * - SHORT is 1 to 63 hex characters inclusive.
     * - Padding zeroes are allowed, e.g. 0x0123 is valid.
     *
     * Learn more about the different address formats by reading AIP-40:
     * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.
     *
     * @param input A hex string representing an account address.
     *
     * @returns An instance of AccountAddress.
     */
    static fromString(input: string): AccountAddress;
    /**
     * Convenience method for creating an AccountAddress from all known inputs.
     *
     * This handles, Uint8array, string, and AccountAddress itself
     * @param input
     */
    static from(input: AccountAddressInput): AccountAddress;
    /**
     * Convenience method for creating an AccountAddress from all known inputs.
     *
     * This handles, Uint8array, string, and AccountAddress itself
     * @param input
     */
    static fromStrict(input: AccountAddressInput): AccountAddress;
    /**
     * Check if the string is a valid AccountAddress.
     *
     * @param args.input A hex string representing an account address.
     * @param args.strict If true, use strict parsing behavior. If false, use relaxed parsing behavior.
     *
     * @returns valid = true if the string is valid, valid = false if not. If the string
     * is not valid, invalidReason will be set explaining why it is invalid.
     */
    static isValid(args: {
        input: AccountAddressInput;
        strict?: boolean;
    }): ParsingResult<AddressInvalidReason>;
    /**
     * Return whether AccountAddresses are equal. AccountAddresses are considered equal
     * if their underlying byte data is identical.
     *
     * @param other The AccountAddress to compare to.
     * @returns true if the AccountAddresses are equal, false if not.
     */
    equals(other: AccountAddress): boolean;
}

export { type GetEventsResponse as $, type AnyNumber as A, type GetAccountOwnedTokensFromCollectionResponse as B, type Client as C, Deserializer as D, type EntryFunctionArgument as E, type FullNodeConfig as F, type GetAccountOwnedTokensQueryResponse as G, type HexInput as H, type IndexerConfig as I, type GetAccountCollectionsWithOwnedTokenResponse as J, type GetAccountCoinsDataResponse as K, type LedgerVersionArg as L, type MoveModuleId as M, Network as N, type OrderByArg as O, type PaginationArgs as P, type GetObjectDataQueryResponse as Q, type GetCollectionDataResponse as R, Serializable as S, type TransactionArgument as T, type Uint8 as U, type GetTokenDataResponse as V, type WhereArg as W, type GetCurrentTokenOwnershipResponse as X, type GetOwnedTokensResponse as Y, ZkpVariant as Z, type GetTokenActivityResponse as _, Serializer as a, type WriteSetChangeWriteTableItem as a$, type WaitForTransactionOptions as a0, type UserTransactionResponse as a1, type MoveFunction as a2, type GetFungibleAssetMetadataResponse as a3, type GetFungibleAssetActivitiesResponse as a4, type GetCurrentFungibleAssetBalancesResponse as a5, type LedgerInfo as a6, type Block as a7, type GetChainTopUserTransactionsResponse as a8, type GraphqlQuery as a9, AccountAuthenticatorVariant as aA, AnySignatureVariant as aB, EphemeralSignatureVariant as aC, type Uint64 as aD, type Uint128 as aE, type Uint256 as aF, type ClientHeadersType as aG, TransactionResponseType as aH, isPendingTransactionResponse as aI, isUserTransactionResponse as aJ, isGenesisTransactionResponse as aK, isBlockMetadataTransactionResponse as aL, isStateCheckpointTransactionResponse as aM, isValidatorTransactionResponse as aN, isBlockEpilogueTransactionResponse as aO, type GenesisTransactionResponse as aP, type BlockMetadataTransactionResponse as aQ, type StateCheckpointTransactionResponse as aR, type ValidatorTransactionResponse as aS, type BlockEndInfo as aT, type BlockEpilogueTransactionResponse as aU, type WriteSetChange as aV, type WriteSetChangeDeleteModule as aW, type WriteSetChangeDeleteResource as aX, type WriteSetChangeDeleteTableItem as aY, type WriteSetChangeWriteModule as aZ, type WriteSetChangeWriteResource as a_, type GetProcessorStatusResponse as aa, type GetANSNameResponse as ab, type GetNumberOfDelegatorsResponse as ac, type GetDelegatedStakingActivitiesResponse as ad, type PendingTransactionResponse as ae, type CommittedTransactionResponse as af, type GasEstimation as ag, type TableItemRequest as ah, type GetTableItemsDataResponse as ai, type GetTableItemsMetadataResponse as aj, type AptosRequest as ak, type ClientRequest as al, type ClientResponse as am, MimeType as an, ensureBoolean as ao, outOfRangeErrorMessage as ap, validateNumberInRange as aq, AddressInvalidReason as ar, ParsingError as as, type ParsingResult as at, HexInvalidReason as au, TypeTagVariants as av, ScriptTransactionArgumentVariants as aw, TransactionPayloadVariants as ax, TransactionVariants as ay, TransactionAuthenticatorVariant as az, type Uint16 as b, type DecodedTableData as b0, type DeletedTableData as b1, type TransactionPayloadResponse as b2, type EntryFunctionPayloadResponse as b3, type ScriptPayloadResponse as b4, type MultisigPayloadResponse as b5, type GenesisPayload as b6, type MoveScriptBytecode as b7, type TransactionSignature as b8, isEd25519Signature as b9, MoveFunctionVisibility as bA, MoveAbility as bB, type MoveStructField as bC, type MoveModule as bD, type MoveStruct as bE, RoleType as bF, DeriveScheme as bG, type GenerateAccountWithEd25519 as bH, type GenerateAccountWithSingleSignerSecp256k1Key as bI, type GenerateAccount as bJ, type OrderBy as bK, type OrderByValue as bL, type TokenStandard as bM, NetworkToIndexerAPI as bN, NetworkToNodeAPI as bO, NetworkToFaucetAPI as bP, NetworkToPepperAPI as bQ, NetworkToProverAPI as bR, NetworkToChainId as bS, NetworkToNetworkName as bT, isSecp256k1Signature as ba, isMultiAgentSignature as bb, isFeePayerSignature as bc, isMultiEd25519Signature as bd, type TransactionEd25519Signature as be, type TransactionSecp256k1Signature as bf, type TransactionMultiEd25519Signature as bg, type TransactionMultiAgentSignature as bh, type TransactionFeePayerSignature as bi, type AccountSignature as bj, type WriteSet as bk, type ScriptWriteSet as bl, type DirectWriteSet as bm, type EventGuid as bn, type Event as bo, type MoveUint8Type as bp, type MoveUint16Type as bq, type MoveUint32Type as br, type MoveUint64Type as bs, type MoveUint128Type as bt, type MoveUint256Type as bu, type MoveAddressType as bv, type MoveObjectType as bw, type MoveOptionType as bx, type MoveStructType as by, type MoveType as bz, type Uint32 as c, type Deserializable as d, Hex as e, type AuthenticationKeyScheme as f, AccountAddress as g, AnyPublicKeyVariant as h, EphemeralPublicKeyVariant as i, type ClientConfig as j, type FaucetConfig as k, type AptosSettings as l, EphemeralCertificateVariant as m, type ScriptFunctionArgument as n, type MoveFunctionId as o, type AccountAddressInput as p, type MoveStructId as q, type MoveValue as r, type MoveFunctionGenericTypeParam as s, SigningSchemeInput as t, SigningScheme as u, type AccountData as v, type MoveModuleBytecode as w, type TransactionResponse as x, type MoveResource as y, type TokenStandardArg as z };
