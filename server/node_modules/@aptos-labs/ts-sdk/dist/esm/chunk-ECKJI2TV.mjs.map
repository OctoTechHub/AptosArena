{"version":3,"sources":["../../src/account/EphemeralKeyPair.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { randomBytes } from \"@noble/hashes/utils\";\n\nimport { Ed25519PrivateKey, EphemeralPublicKey, EphemeralSignature, PrivateKey } from \"../core/crypto\";\nimport { Hex } from \"../core/hex\";\nimport { bytesToBigIntLE, padAndPackBytesWithLen, poseidonHash } from \"../core/crypto/poseidon\";\nimport { EphemeralPublicKeyVariant, HexInput } from \"../types\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { floorToWholeHour, nowInSeconds } from \"../utils/helpers\";\n\nconst TWO_WEEKS_IN_SECONDS = 1_209_600;\n\n/**\n * A class which contains a key pair that is used in signing transactions via the Keyless authentication scheme. This key pair\n * is ephemeral and has an expiration time.  For more details on how this class is used -\n * https://aptos.dev/guides/keyless-accounts/#1-present-the-user-with-a-sign-in-with-idp-button-on-the-ui\n */\nexport class EphemeralKeyPair extends Serializable {\n  static readonly BLINDER_LENGTH: number = 31;\n\n  /**\n   * A byte array of length BLINDER_LENGTH used to obfuscate the public key from the IdP.\n   * Used in calculating the nonce passed to the IdP and as a secret witness in proof generation.\n   */\n  readonly blinder: Uint8Array;\n\n  /**\n   * A timestamp in seconds indicating when the ephemeral key pair is expired.  After expiry, a new\n   * EphemeralKeyPair must be generated and a new JWT needs to be created.\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The value passed to the IdP when the user authenticates.  It comprises of a hash of the\n   * ephermeral public key, expiry date, and blinder.\n   */\n  readonly nonce: string;\n\n  /**\n   * A private key used to sign transactions.  This private key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   */\n  private privateKey: PrivateKey;\n\n  /**\n   * A public key used to verify transactions.  This public key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   */\n  private publicKey: EphemeralPublicKey;\n\n  constructor(args: { privateKey: PrivateKey; expiryDateSecs?: number; blinder?: HexInput }) {\n    super();\n    const { privateKey, expiryDateSecs, blinder } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new EphemeralPublicKey(privateKey.publicKey());\n    // By default, we set the expiry date to be two weeks in the future floored to the nearest hour\n    this.expiryDateSecs = expiryDateSecs || floorToWholeHour(nowInSeconds() + TWO_WEEKS_IN_SECONDS);\n    // Generate the blinder if not provided\n    this.blinder = blinder !== undefined ? Hex.fromHexInput(blinder).toUint8Array() : generateBlinder();\n    // Calculate the nonce\n    const fields = padAndPackBytesWithLen(this.publicKey.bcsToBytes(), 93);\n    fields.push(BigInt(this.expiryDateSecs));\n    fields.push(bytesToBigIntLE(this.blinder));\n    const nonceHash = poseidonHash(fields);\n    this.nonce = nonceHash.toString();\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @return EphemeralPublicKey\n   */\n  getPublicKey(): EphemeralPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @return boolean\n   */\n  isExpired(): boolean {\n    const currentTimeSecs: number = Math.floor(Date.now() / 1000);\n    return currentTimeSecs > this.expiryDateSecs;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.publicKey.variant);\n    serializer.serializeBytes(this.privateKey.toUint8Array());\n    serializer.serializeU64(this.expiryDateSecs);\n    serializer.serializeFixedBytes(this.blinder);\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralKeyPair {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let privateKey: PrivateKey;\n    switch (variantIndex) {\n      case EphemeralPublicKeyVariant.Ed25519:\n        privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for EphemeralPublicKey: ${variantIndex}`);\n    }\n    const expiryDateSecs = deserializer.deserializeU64();\n    const blinder = deserializer.deserializeFixedBytes(31);\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: Number(expiryDateSecs), blinder });\n  }\n\n  static fromBytes(bytes: Uint8Array): EphemeralKeyPair {\n    return EphemeralKeyPair.deserialize(new Deserializer(bytes));\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @param scheme the type of keypair to use for the EphemeralKeyPair.  Only Ed25519 supported for now.\n   * @param expiryDateSecs the date of expiry.\n   * @return boolean\n   */\n  static generate(args?: { scheme?: EphemeralPublicKeyVariant; expiryDateSecs?: number }): EphemeralKeyPair {\n    let privateKey: PrivateKey;\n\n    switch (args?.scheme) {\n      case EphemeralPublicKeyVariant.Ed25519:\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: args?.expiryDateSecs });\n  }\n\n  /**\n   * Sign the given message with the private key.\n   * @param data in HexInput format\n   * @returns EphemeralSignature\n   */\n  sign(data: HexInput): EphemeralSignature {\n    if (this.isExpired()) {\n      throw new Error(\"EphemeralKeyPair has expired\");\n    }\n    return new EphemeralSignature(this.privateKey.sign(data));\n  }\n}\n\n/**\n * Generates a random byte array of length EphemeralKeyPair.BLINDER_LENGTH\n * @returns Uint8Array\n */\nfunction generateBlinder(): Uint8Array {\n  return randomBytes(EphemeralKeyPair.BLINDER_LENGTH);\n}\n"],"mappings":"sTAGA,OAAS,eAAAA,MAAmB,sBAS5B,IAAMC,EAAuB,QAOhBC,EAAN,MAAMA,UAAyBC,CAAa,CAiCjD,YAAYC,EAA+E,CACzF,MAAM,EACN,GAAM,CAAE,WAAAC,EAAY,eAAAC,EAAgB,QAAAC,CAAQ,EAAIH,EAChD,KAAK,WAAaC,EAClB,KAAK,UAAY,IAAIG,EAAmBH,EAAW,UAAU,CAAC,EAE9D,KAAK,eAAiBC,GAAkBG,EAAiBC,EAAa,EAAIT,CAAoB,EAE9F,KAAK,QAAUM,IAAY,OAAYI,EAAI,aAAaJ,CAAO,EAAE,aAAa,EAAIK,EAAgB,EAElG,IAAMC,EAASC,EAAuB,KAAK,UAAU,WAAW,EAAG,EAAE,EACrED,EAAO,KAAK,OAAO,KAAK,cAAc,CAAC,EACvCA,EAAO,KAAKE,EAAgB,KAAK,OAAO,CAAC,EACzC,IAAMC,EAAYC,EAAaJ,CAAM,EACrC,KAAK,MAAQG,EAAU,SAAS,CAClC,CAMA,cAAmC,CACjC,OAAO,KAAK,SACd,CAMA,WAAqB,CAEnB,OADgC,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EACnC,KAAK,cAChC,CAEA,UAAUE,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,UAAU,OAAO,EACvDA,EAAW,eAAe,KAAK,WAAW,aAAa,CAAC,EACxDA,EAAW,aAAa,KAAK,cAAc,EAC3CA,EAAW,oBAAoB,KAAK,OAAO,CAC7C,CAEA,OAAO,YAAYC,EAA8C,CAC/D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDd,EACJ,OAAQe,EAAc,CACpB,OACEf,EAAagB,EAAkB,YAAYF,CAAY,EACvD,MACF,QACE,MAAM,IAAI,MAAM,iDAAiDC,CAAY,EAAE,CACnF,CACA,IAAMd,EAAiBa,EAAa,eAAe,EAC7CZ,EAAUY,EAAa,sBAAsB,EAAE,EACrD,OAAO,IAAIjB,EAAiB,CAAE,WAAAG,EAAY,eAAgB,OAAOC,CAAc,EAAG,QAAAC,CAAQ,CAAC,CAC7F,CAEA,OAAO,UAAUe,EAAqC,CACpD,OAAOpB,EAAiB,YAAY,IAAIqB,EAAaD,CAAK,CAAC,CAC7D,CAQA,OAAO,SAASlB,EAA0F,CACxG,IAAIC,EAEJ,OAAQD,GAAM,OAAQ,CACpB,OACA,QACEC,EAAagB,EAAkB,SAAS,CAC5C,CAEA,OAAO,IAAInB,EAAiB,CAAE,WAAAG,EAAY,eAAgBD,GAAM,cAAe,CAAC,CAClF,CAOA,KAAKoB,EAAoC,CACvC,GAAI,KAAK,UAAU,EACjB,MAAM,IAAI,MAAM,8BAA8B,EAEhD,OAAO,IAAIC,EAAmB,KAAK,WAAW,KAAKD,CAAI,CAAC,CAC1D,CACF,EA1HatB,EACK,eAAyB,GADpC,IAAMwB,EAANxB,EAgIP,SAASU,GAA8B,CACrC,OAAOe,EAAYD,EAAiB,cAAc,CACpD","names":["randomBytes","TWO_WEEKS_IN_SECONDS","_EphemeralKeyPair","Serializable","args","privateKey","expiryDateSecs","blinder","EphemeralPublicKey","floorToWholeHour","nowInSeconds","Hex","generateBlinder","fields","padAndPackBytesWithLen","bytesToBigIntLE","nonceHash","poseidonHash","serializer","deserializer","variantIndex","Ed25519PrivateKey","bytes","Deserializer","data","EphemeralSignature","EphemeralKeyPair","randomBytes"]}