import{a}from"./chunk-A63SMUOU.mjs";import{a as i}from"./chunk-LG7RJQ57.mjs";import{bytesToHex as o,hexToBytes as l}from"@noble/hashes/utils";var g=(s=>(s.INCORRECT_NUMBER_OF_BYTES="incorrect_number_of_bytes",s.INVALID_HEX_CHARS="invalid_hex_chars",s.TOO_SHORT="too_short",s.TOO_LONG="too_long",s.LEADING_ZERO_X_REQUIRED="leading_zero_x_required",s.LONG_FORM_REQUIRED_UNLESS_SPECIAL="long_form_required_unless_special",s.INVALID_PADDING_ZEROES="INVALID_PADDING_ZEROES",s))(g||{}),r=class r extends a{constructor(t){if(super(),t.length!==r.LENGTH)throw new i("AccountAddress data should be exactly 32 bytes long","incorrect_number_of_bytes");this.data=t}isSpecial(){return this.data.slice(0,this.data.length-1).every(t=>t===0)&&this.data[this.data.length-1]<16}toString(){return`0x${this.toStringWithoutPrefix()}`}toStringWithoutPrefix(){let t=o(this.data);return this.isSpecial()&&(t=t[t.length-1]),t}toStringLong(){return`0x${this.toStringLongWithoutPrefix()}`}toStringLongWithoutPrefix(){return o(this.data)}toUint8Array(){return this.data}serialize(t){t.serializeFixedBytes(this.data)}serializeForEntryFunction(t){let e=this.bcsToBytes();t.serializeBytes(e)}serializeForScriptFunction(t){t.serializeU32AsUleb128(3),t.serialize(this)}static deserialize(t){let e=t.deserializeFixedBytes(r.LENGTH);return new r(e)}static fromStringStrict(t){if(!t.startsWith("0x"))throw new i("Hex string must start with a leading 0x.","leading_zero_x_required");let e=r.fromString(t);if(t.length!==r.LONG_STRING_LENGTH+2)if(e.isSpecial()){if(t.length!==3)throw new i(`The given hex string ${t} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,"INVALID_PADDING_ZEROES")}else throw new i(`The given hex string ${t} is not a special address, it must be represented as 0x + 64 chars.`,"long_form_required_unless_special");return e}static fromString(t){let e=t;if(t.startsWith("0x")&&(e=t.slice(2)),e.length===0)throw new i("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.","too_short");if(e.length>64)throw new i("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.","too_long");let n;try{n=l(e.padStart(64,"0"))}catch(c){throw new i(`Hex characters are invalid: ${c?.message}`,"invalid_hex_chars")}return new r(n)}static from(t){return typeof t=="string"?r.fromString(t):t instanceof Uint8Array?new r(t):t}static fromStrict(t){return typeof t=="string"?r.fromStringStrict(t):t instanceof Uint8Array?new r(t):t}static isValid(t){try{return t.strict?r.fromStrict(t.input):r.from(t.input),{valid:!0}}catch(e){return{valid:!1,invalidReason:e?.invalidReason,invalidReasonMessage:e?.message}}}equals(t){return this.data.length!==t.data.length?!1:this.data.every((e,n)=>e===t.data[n])}};r.LENGTH=32,r.LONG_STRING_LENGTH=64,r.ZERO=r.from("0x0"),r.ONE=r.from("0x1"),r.TWO=r.from("0x2"),r.THREE=r.from("0x3"),r.FOUR=r.from("0x4"),r.A=r.from("0xA");var d=r;export{g as a,d as b};
//# sourceMappingURL=chunk-OHRL766V.mjs.map