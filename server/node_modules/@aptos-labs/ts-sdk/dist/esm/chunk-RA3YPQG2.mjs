import{a as T}from"./chunk-ECKJI2TV.mjs";import{a as x,b as v}from"./chunk-3NRBTP3S.mjs";import{d as g}from"./chunk-Q67DUNMI.mjs";import{a as y,b as m}from"./chunk-NU55IEL4.mjs";import{i as F,j as E,k as b,n as f}from"./chunk-4ZMI5G5L.mjs";import{b as S}from"./chunk-OHRL766V.mjs";import{d as A}from"./chunk-ZOMXBB6Z.mjs";import{a as w}from"./chunk-KEYAPEAX.mjs";import{a as d}from"./chunk-A63SMUOU.mjs";import{b as K}from"./chunk-BCUSI3N6.mjs";import{jwtDecode as z}from"jwt-decode";import Z from"eventemitter3";var o=class o extends d{constructor(e){super();let{address:r,ephemeralKeyPair:t,uidKey:i,uidVal:a,aud:c,pepper:p,proof:n,proofFetchCallback:s,jwt:l}=e;if(this.ephemeralKeyPair=t,this.publicKey=F.create(e),this.accountAddress=r?S.from(r):this.publicKey.authKey().derivedAddress(),this.uidKey=i,this.uidVal=a,this.aud=c,this.jwt=l,this.emitter=new Z,this.proofOrPromise=n,n instanceof f)this.proof=n;else{if(s===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async u=>{await s(u),this.emitter.removeAllListeners()}),this.init(n)}this.signingScheme=2;let h=K.fromHexInput(p).toUint8Array();if(h.length!==o.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${o.PEPPER_LENGTH}`);this.pepper=h}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(r){r instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:r.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Connot serialize - proof undefined");this.proof.serialize(e)}static deserialize(e){let r=e.deserializeStr(),t=e.deserializeStr(),i=e.deserializeFixedBytes(31),a=T.deserialize(e),c=f.deserialize(e);return o.create({proof:c,pepper:i,uidKey:t,jwt:r,ephemeralKeyPair:a})}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let r=new m(this.sign(e)),t=new y(this.publicKey);return new g(t,r)}signTransactionWithAuthenticator(e){let r=new m(this.signTransaction(e)),t=new y(this.publicKey);return new g(t,r)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}sign(e){let{expiryDateSecs:r}=this.ephemeralKeyPair;if(this.isExpired())throw new Error("EphemeralKeyPair is expired");if(this.proof===void 0)throw new Error("Proof not defined");let t=this.ephemeralKeyPair.getPublicKey(),i=this.ephemeralKeyPair.sign(e);return new E({jwtHeader:A(this.jwt.split(".")[0]),ephemeralCertificate:new b(this.proof,0),expiryDateSecs:r,ephemeralPublicKey:t,ephemeralSignature:i})}signTransaction(e){if(this.proof===void 0)throw new Error("Proof not found");let r=x(e),i=new P(r,this.proof.proof).hash();return this.sign(i)}verifySignature(e){let{message:r,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:r,signature:t.ephemeralSignature}))}static fromBytes(e){return o.deserialize(new w(e))}static create(e){let{address:r,proof:t,jwt:i,ephemeralKeyPair:a,pepper:c,uidKey:p="sub",proofFetchCallback:n}=e,s=z(i),l=s.iss;if(typeof s.aud!="string")throw new Error("aud was not found or an array of values");let h=s.aud,u=s[p];return new o({address:r,proof:t,ephemeralKeyPair:a,iss:l,uidKey:p,uidVal:u,aud:h,pepper:c,jwt:i,proofFetchCallback:n})}};o.PEPPER_LENGTH=31;var k=o,P=class extends d{constructor(r,t){super();this.domainSeparator="APTOS::TransactionAndProof";this.transaction=r,this.proof=t}serialize(r){r.serializeFixedBytes(this.transaction.bcsToBytes()),r.serializeOption(this.proof)}hash(){return v(this.bcsToBytes(),this.domainSeparator)}};export{k as a};
//# sourceMappingURL=chunk-RA3YPQG2.mjs.map