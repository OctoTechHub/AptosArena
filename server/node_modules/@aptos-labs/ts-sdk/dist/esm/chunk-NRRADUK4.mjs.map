{"version":3,"sources":["../../src/internal/ans.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/name}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * name namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { GetANSNameResponse, MoveAddressType, OrderByArg, PaginationArgs, WhereArg } from \"../types\";\nimport { GetNamesQuery } from \"../types/generated/operations\";\nimport { GetNames } from \"../types/generated/queries\";\nimport { CurrentAptosNamesBoolExp } from \"../types/generated/types\";\nimport { Network } from \"../utils/apiEndpoints\";\nimport { queryIndexer } from \"./general\";\nimport { view } from \"./view\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nexport const VALIDATION_RULES_DESCRIPTION = [\n  \"A name must be between 3 and 63 characters long,\",\n  \"and can only contain lowercase a-z, 0-9, and hyphens.\",\n  \"A name may not start or end with a hyphen.\",\n].join(\" \");\n\n/**\n *\n * @param fragment A fragment of a name, either the domain or subdomain\n * @returns boolean indicating if the fragment is a valid fragment\n */\nexport function isValidANSSegment(fragment: string): boolean {\n  if (!fragment) return false;\n  if (fragment.length < 3) return false;\n  if (fragment.length > 63) return false;\n  // only lowercase a-z and 0-9 are allowed, along with -. a domain may not start or end with a hyphen\n  if (!/^[a-z\\d][a-z\\d-]{1,61}[a-z\\d]$/.test(fragment)) return false;\n  return true;\n}\n\n/**\n * Checks if an ANS name is valid or not\n *\n * @param name A string of the domain name, can include or exclude the .apt suffix\n */\nexport function isValidANSName(name: string): { domainName: string; subdomainName?: string } {\n  const [first, second, ...rest] = name.replace(/\\.apt$/, \"\").split(\".\");\n\n  if (rest.length > 0) {\n    throw new Error(`${name} is invalid. A name can only have two parts, a domain and a subdomain separated by a \".\"`);\n  }\n\n  if (!isValidANSSegment(first)) {\n    throw new Error(`${first} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  if (second && !isValidANSSegment(second)) {\n    throw new Error(`${second} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  return {\n    domainName: second || first,\n    subdomainName: second ? first : undefined,\n  };\n}\n\nexport enum SubdomainExpirationPolicy {\n  Independent = 0,\n  FollowsDomain = 1,\n}\n\n/**\n * A helper function to determine if a given ANS name is considered active or\n * not. Domains are considered active if their expiration date is in the\n * future. Subdomains have two policies which modify their behavior. They can\n * follow their parent's expiration (1) in which they ignore their own\n * expiration timestamp or they can expire independently (0) in which they can\n * expire before their parent but not afterwards.\n *\n * @param name - An ANS name returned from one of the functions of the SDK\n * @returns A boolean representing if the contract considers the name active or not\n */\nexport function isActiveANSName(name: GetANSNameResponse[0]): boolean {\n  if (!name) return false;\n\n  const isTLDExpired = new Date(name.domain_expiration_timestamp).getTime() < Date.now();\n  const isExpired = new Date(name.expiration_timestamp).getTime() < Date.now();\n\n  // If we are a subdomain, if our parent is expired we are always expired\n  if (name.subdomain && isTLDExpired) return false;\n\n  // If we are a subdomain and our expiration policy is to follow the domain, we\n  // are active (since we know our parent is not expired by this point)\n  if (name.subdomain && name.subdomain_expiration_policy === SubdomainExpirationPolicy.FollowsDomain) return true;\n\n  // At this point, we are either a TLD or a subdomain with an independent\n  // expiration policy, we are active as long as we the expiration timestamp\n  return !isExpired;\n}\n\nexport const LOCAL_ANS_ACCOUNT_PK =\n  process.env.ANS_TEST_ACCOUNT_PRIVATE_KEY ?? \"0x37368b46ce665362562c6d1d4ec01a08c8644c488690df5a17e13ba163e20221\";\nexport const LOCAL_ANS_ACCOUNT_ADDRESS =\n  process.env.ANS_TEST_ACCOUNT_ADDRESS ?? \"0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82\";\n\nconst NetworkToAnsContract: Record<Network, string | null> = {\n  [Network.TESTNET]: \"0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c\",\n  [Network.MAINNET]: \"0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c\",\n  [Network.LOCAL]: LOCAL_ANS_ACCOUNT_ADDRESS,\n  [Network.CUSTOM]: null,\n  [Network.DEVNET]: null,\n};\n\nfunction getRouterAddress(aptosConfig: AptosConfig): string {\n  const address = NetworkToAnsContract[aptosConfig.network];\n  if (!address) throw new Error(`The ANS contract is not deployed to ${aptosConfig.network}`);\n  return address;\n}\n\nconst unwrapOption = <T>(option: any): T | undefined => {\n  if (!!option && typeof option === \"object\" && \"vec\" in option && Array.isArray(option.vec)) {\n    return option.vec[0];\n  }\n\n  return undefined;\n};\n\nexport async function getOwnerAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_owner_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const owner = unwrapOption<MoveAddressType>(res[0]);\n\n  return owner ? AccountAddress.from(owner) : undefined;\n}\n\nexport interface RegisterNameParameters {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  expiration:\n    | { policy: \"domain\"; years?: 1 }\n    | { policy: \"subdomain:follow-domain\" }\n    | { policy: \"subdomain:independent\"; expirationDate: number };\n  transferable?: boolean;\n  toAddress?: AccountAddressInput;\n  targetAddress?: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}\n\nexport async function registerName(args: RegisterNameParameters): Promise<SimpleTransaction> {\n  const { aptosConfig, expiration, name, sender, targetAddress, toAddress, options, transferable } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const hasSubdomainPolicy =\n    expiration.policy === \"subdomain:independent\" || expiration.policy === \"subdomain:follow-domain\";\n\n  if (subdomainName && !hasSubdomainPolicy) {\n    throw new Error(\n      \"Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'\",\n    );\n  }\n\n  if (hasSubdomainPolicy && !subdomainName) {\n    throw new Error(`Policy is set to ${expiration.policy} but no subdomain was provided`);\n  }\n\n  if (expiration.policy === \"domain\") {\n    const years = expiration.years ?? 1;\n    if (years !== 1) {\n      throw new Error(\"For now, names can only be registered for 1 year at a time\");\n    }\n\n    const secondsInYear = 31536000;\n    const registrationDuration = years * secondsInYear;\n\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::register_domain`,\n        functionArguments: [domainName, registrationDuration, targetAddress, toAddress],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  // We are a subdomain\n  if (!subdomainName) {\n    throw new Error(`${expiration.policy} requires a subdomain to be provided.`);\n  }\n\n  const tldExpiration = await getExpiration({ aptosConfig, name: domainName });\n  if (!tldExpiration) {\n    throw new Error(\"The domain does not exist\");\n  }\n\n  const expirationDateInMillisecondsSinceEpoch =\n    expiration.policy === \"subdomain:independent\" ? expiration.expirationDate : tldExpiration;\n\n  if (expirationDateInMillisecondsSinceEpoch > tldExpiration) {\n    throw new Error(\"The subdomain expiration time cannot be greater than the domain expiration time\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::register_subdomain`,\n      functionArguments: [\n        domainName,\n        subdomainName,\n        Math.round(expirationDateInMillisecondsSinceEpoch / 1000),\n        expiration.policy === \"subdomain:follow-domain\" ? 1 : 0,\n        !!transferable,\n        targetAddress,\n        toAddress,\n      ],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\nexport async function getExpiration(args: { aptosConfig: AptosConfig; name: string }): Promise<number | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  try {\n    const res = await view({\n      aptosConfig,\n      payload: {\n        function: `${routerAddress}::router::get_expiration`,\n        functionArguments: [domainName, subdomainName],\n      },\n    });\n\n    // Normalize expiration time from epoch seconds to epoch milliseconds\n    return Number(res[0]) * 1000;\n  } catch (e) {\n    return undefined;\n  }\n}\n\nexport async function getPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  address: AccountAddressInput;\n}): Promise<string | undefined> {\n  const { aptosConfig, address } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_primary_name`,\n      functionArguments: [AccountAddress.from(address).toString()],\n    },\n  });\n\n  const domainName = unwrapOption<MoveAddressType>(res[1]);\n  const subdomainName = unwrapOption<MoveAddressType>(res[0]);\n\n  if (!domainName) return undefined;\n\n  return [subdomainName, domainName].filter(Boolean).join(\".\");\n}\n\nexport async function setPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  if (!name) {\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::clear_primary_name`,\n        functionArguments: [],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_primary_name`,\n      functionArguments: [domainName, subdomainName],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\nexport async function getTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_target_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const target = unwrapOption<MoveAddressType>(res[0]);\n  return target ? AccountAddress.from(target) : undefined;\n}\n\nexport async function setTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  address: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, address, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_target_addr`,\n      functionArguments: [domainName, subdomainName, address],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\nexport async function getName(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<GetANSNameResponse[0] | undefined> {\n  const { aptosConfig, name } = args;\n  const { domainName, subdomainName = \"\" } = isValidANSName(name);\n\n  const where: CurrentAptosNamesBoolExp = {\n    domain: { _eq: domainName },\n    subdomain: { _eq: subdomainName },\n  };\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    query: {\n      query: GetNames,\n      variables: {\n        where_condition: where,\n        limit: 1,\n      },\n    },\n    originMethod: \"getName\",\n  });\n\n  // Convert the expiration_timestamp from an ISO string to milliseconds since epoch\n  let res = data.current_aptos_names[0];\n  if (res) {\n    res = sanitizeANSName(res);\n  }\n\n  return isActiveANSName(res) ? res : undefined;\n}\n\ninterface QueryNamesOptions {\n  options?: PaginationArgs & OrderByArg<GetANSNameResponse[0]> & WhereArg<CurrentAptosNamesBoolExp>;\n}\n\nexport interface GetAccountNamesArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\nexport async function getAccountNames(\n  args: { aptosConfig: AptosConfig } & GetAccountNamesArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountNames\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\nexport interface GetAccountDomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\nexport async function getAccountDomains(\n  args: { aptosConfig: AptosConfig } & GetAccountDomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountDomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _eq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\nexport interface GetAccountSubdomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\nexport async function getAccountSubdomains(\n  args: { aptosConfig: AptosConfig } & GetAccountSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\nexport interface GetDomainSubdomainsArgs extends QueryNamesOptions {\n  domain: string;\n}\n\nexport async function getDomainSubdomains(\n  args: { aptosConfig: AptosConfig } & GetDomainSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, domain } = args;\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getDomainSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          domain: { _eq: domain },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName).filter(isActiveANSName);\n}\n\n/**\n * This function returns the expiration date in which a name is fully expired as\n * defined by the contract.  The grace period allows for names to be past\n * expiration for a certain amount of time before they are released to the\n * public. The names will not function as normal, but the owner can renew\n * without others taking ownership of the name. At the time of writing, the\n * contract specified 30 days.\n *\n * @param args.aptosConfig an AptosConfig object\n * @returns\n */\nasync function getANSExpirationDate(args: { aptosConfig: AptosConfig }): Promise<string> {\n  const { aptosConfig } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const [gracePeriodInSeconds] = await view<[number]>({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::config::reregistration_grace_sec`,\n      functionArguments: [],\n    },\n  });\n\n  const gracePeriodInDays = gracePeriodInSeconds / 60 / 60 / 24;\n  const now = () => new Date();\n  return new Date(now().setDate(now().getDate() - gracePeriodInDays)).toISOString();\n}\n\nexport async function renewDomain(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  years?: 1;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, years = 1, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const renewalDuration = years * 31536000;\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  if (subdomainName) {\n    throw new Error(\"Subdomains cannot be renewed\");\n  }\n\n  if (years !== 1) {\n    throw new Error(\"Currently, only 1 year renewals are supported\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::renew_domain`,\n      functionArguments: [domainName, renewalDuration],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * The indexer returns ISO strings for expiration, however the contract works in\n * epoch milliseconds. This function converts the ISO string to epoch\n * milliseconds. In the future, if other properties need sanitization, this can\n * be extended.\n */\nfunction sanitizeANSName(name: GetANSNameResponse[0]): GetANSNameResponse[0] {\n  return {\n    ...name,\n    expiration_timestamp: new Date(name.expiration_timestamp).getTime(),\n  };\n}\n"],"mappings":"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","names":["VALIDATION_RULES_DESCRIPTION","isValidANSSegment","fragment","isValidANSName","name","first","second","rest","SubdomainExpirationPolicy","isActiveANSName","isTLDExpired","isExpired","LOCAL_ANS_ACCOUNT_PK","LOCAL_ANS_ACCOUNT_ADDRESS","NetworkToAnsContract","getRouterAddress","aptosConfig","address","unwrapOption","option","getOwnerAddress","args","routerAddress","domainName","subdomainName","res","view","owner","AccountAddress","registerName","expiration","sender","targetAddress","toAddress","options","transferable","hasSubdomainPolicy","years","registrationDuration","generateTransaction","tldExpiration","getExpiration","expirationDateInMillisecondsSinceEpoch","getPrimaryName","setPrimaryName","getTargetAddress","target","setTargetAddress","getName","queryIndexer","GetNames","sanitizeANSName","getAccountNames","accountAddress","expirationDate","getANSExpirationDate","getAccountDomains","getAccountSubdomains","getDomainSubdomains","domain","gracePeriodInSeconds","gracePeriodInDays","now","renewDomain","renewalDuration"]}