import{b as h,d as l}from"./chunk-Q7MD4V7H.mjs";import{b as E}from"./chunk-76OH2Z4Q.mjs";import{a as p}from"./chunk-MLDQ2TY2.mjs";import{a as g}from"./chunk-G5MGSV7Y.mjs";var o=class o extends E{constructor(r){super();let{publicKeys:e,threshold:t}=r;if(e.length>o.MAX_KEYS||e.length<o.MIN_KEYS)throw new Error(`Must have between ${o.MIN_KEYS} and ${o.MAX_KEYS} public keys, inclusive`);if(t<o.MIN_THRESHOLD||t>e.length)throw new Error(`Threshold must be between ${o.MIN_THRESHOLD} and ${e.length}, inclusive`);this.publicKeys=e,this.threshold=t}verifySignature(r){let{message:e,signature:t}=r;if(!(t instanceof y))return!1;let s=[];for(let i=0;i<4;i+=1)for(let n=0;n<8;n+=1)if((t.bitmap[i]&1<<7-n)!==0){let u=i*8+n;s.push(u)}if(s.length!==t.signatures.length)throw new Error("Bitmap and signatures length mismatch");if(s.length<this.threshold)throw new Error("Not enough signatures");for(let i=0;i<s.length;i+=1)if(!this.publicKeys[s[i]].verifySignature({message:e,signature:t.signatures[i]}))return!1;return!0}authKey(){return g.fromSchemeAndBytes({scheme:1,input:this.toUint8Array()})}toUint8Array(){let r=new Uint8Array(this.publicKeys.length*h.LENGTH+1);return this.publicKeys.forEach((e,t)=>{r.set(e.toUint8Array(),t*h.LENGTH)}),r[this.publicKeys.length*h.LENGTH]=this.threshold,r}serialize(r){r.serializeBytes(this.toUint8Array())}static deserialize(r){let e=r.deserializeBytes(),t=e[e.length-1],s=[];for(let i=0;i<e.length-1;i+=h.LENGTH){let n=i;s.push(new h(e.subarray(n,n+h.LENGTH)))}return new o({publicKeys:s,threshold:t})}};o.MAX_KEYS=32,o.MIN_KEYS=2,o.MIN_THRESHOLD=1;var d=o,a=class a extends p{constructor(r){super();let{signatures:e,bitmap:t}=r;if(e.length>a.MAX_SIGNATURES_SUPPORTED)throw new Error(`The number of signatures cannot be greater than ${a.MAX_SIGNATURES_SUPPORTED}`);if(this.signatures=e,!(t instanceof Uint8Array))this.bitmap=a.createBitmap({bits:t});else{if(t.length!==a.BITMAP_LEN)throw new Error(`"bitmap" length should be ${a.BITMAP_LEN}`);this.bitmap=t}}toUint8Array(){let r=new Uint8Array(this.signatures.length*l.LENGTH+a.BITMAP_LEN);return this.signatures.forEach((e,t)=>{r.set(e.toUint8Array(),t*l.LENGTH)}),r.set(this.bitmap,this.signatures.length*l.LENGTH),r}serialize(r){r.serializeBytes(this.toUint8Array())}static deserialize(r){let e=r.deserializeBytes(),t=e.subarray(e.length-4),s=[];for(let i=0;i<e.length-t.length;i+=l.LENGTH){let n=i;s.push(new l(e.subarray(n,n+l.LENGTH)))}return new a({signatures:s,bitmap:t})}static createBitmap(r){let{bits:e}=r,t=128,s=new Uint8Array([0,0,0,0]),i=new Set;return e.forEach((n,c)=>{if(n>=a.MAX_SIGNATURES_SUPPORTED)throw new Error(`Cannot have a signature larger than ${a.MAX_SIGNATURES_SUPPORTED-1}.`);if(i.has(n))throw new Error("Duplicate bits detected.");if(c>0&&n<=e[c-1])throw new Error("The bits need to be sorted in ascending order.");i.add(n);let u=Math.floor(n/8),b=s[u];b|=t>>n%8,s[u]=b}),s}};a.MAX_SIGNATURES_SUPPORTED=32,a.BITMAP_LEN=4;var y=a;export{d as a,y as b};
//# sourceMappingURL=chunk-UWPO7WWS.mjs.map