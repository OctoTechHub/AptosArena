import { AccountAuthenticatorSingleKey, AccountAuthenticator, AccountAuthenticatorEd25519 } from './transactions/authenticator/account.mjs';
import { SigningSchemeInput, HexInput, SigningScheme } from './types/index.mjs';
import { AccountAddressInput, AccountAddress } from './core/accountAddress.mjs';
import { Ed25519PrivateKey, Ed25519Signature, Ed25519PublicKey } from './core/crypto/ed25519.mjs';
import { a as AccountPublicKey, A as AuthenticationKey, V as VerifySignatureArgs } from './publicKey-B3XRNhHO.mjs';
import { Signature } from './core/crypto/signature.mjs';
import { PrivateKey } from './core/crypto/privateKey.mjs';
import { AnyRawTransaction } from './transactions/types.mjs';
import { AnySignature, AnyPublicKey } from './core/crypto/singleKey.mjs';

interface SingleKeySignerConstructorArgs {
    privateKey: PrivateKey;
    address?: AccountAddressInput;
}
interface SingleKeySignerGenerateArgs {
    scheme?: SigningSchemeInput;
}
type SingleKeySignerFromDerivationPathArgs = SingleKeySignerGenerateArgs & {
    path: string;
    mnemonic: string;
};
interface VerifySingleKeySignatureArgs {
    message: HexInput;
    signature: AnySignature;
}
/**
 * Signer implementation for the SingleKey authentication scheme.
 * This extends a SingleKeyAccount by adding signing capabilities through a valid private key.
 * Currently, the only supported signature schemes are Ed25519 and Secp256k1.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class SingleKeyAccount implements Account {
    /**
     * Private key associated with the account
     */
    readonly privateKey: PrivateKey;
    readonly publicKey: AnyPublicKey;
    readonly accountAddress: AccountAddress;
    readonly signingScheme = SigningScheme.SingleKey;
    constructor(args: SingleKeySignerConstructorArgs);
    /**
     * Derives an account from a randomly generated private key.
     * Default generation is using an Ed25519 key
     * @returns Account with the given signature scheme
     */
    static generate(args?: SingleKeySignerGenerateArgs): SingleKeyAccount;
    /**
     * Derives an account with bip44 path and mnemonics,
     * Default to using an Ed25519 signature scheme.
     *
     * @param args.scheme The signature scheme to derive the private key with
     * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,
     * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: SingleKeySignerFromDerivationPathArgs): SingleKeyAccount;
    /**
     * Verify the given message and signature with the public key.
     *
     * @param args.message raw message data in HexInput format
     * @param args.signature signed message Signature
     * @returns
     */
    verifySignature(args: VerifySingleKeySignatureArgs): boolean;
    /**
     * Sign a message using the account's private key.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey;
    /**
     * Sign a transaction using the account's private key.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey;
    /**
     * Sign the given message using the account's private key.
     * @param message in HexInput format
     * @returns Signature
     */
    sign(message: HexInput): AnySignature;
    /**
     * Sign the given transaction using the account's private key.
     * @param transaction the transaction to be signed
     * @returns Signature
     */
    signTransaction(transaction: AnyRawTransaction): AnySignature;
}

/**
 * Arguments for creating an `Ed25519Account` from an `Ed25519PrivateKey`.
 * This is the default input type when passing an `Ed25519PrivateKey`.
 * In order to use the SingleKey authentication scheme, `legacy` needs to be explicitly set to false.
 */
interface CreateEd25519AccountFromPrivateKeyArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
    legacy?: true;
}
/**
 * Arguments for creating an `SingleKeyAccount` from an `Ed25519PrivateKey`.
 * The `legacy` argument needs to be explicitly set to false in order to
 * use the `SingleKey` authentication scheme.
 */
interface CreateEd25519SingleKeyAccountFromPrivateKeyArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
    legacy: false;
}
/**
 * Arguments for creating an `SingleKeyAccount` from any supported private key
 * that is not an `Ed25519PrivateKey`.
 * The `legacy` argument defaults to false and cannot be explicitly set to true.
 */
interface CreateSingleKeyAccountFromPrivateKeyArgs {
    privateKey: Exclude<PrivateKey, Ed25519PrivateKey>;
    address?: AccountAddressInput;
    legacy?: false;
}
/**
 * Arguments for creating an opaque `Account` from any supported private key.
 * This is used when the private key type is not known at compilation time.
 */
interface CreateAccountFromPrivateKeyArgs {
    privateKey: PrivateKey;
    address?: AccountAddressInput;
    legacy?: boolean;
}
/**
 * Arguments for generating an `Ed25519Account`.
 * This is the input type used by default.
 */
interface GenerateEd25519AccountArgs {
    scheme?: SigningSchemeInput.Ed25519;
    legacy?: true;
}
/**
 * Arguments for generating an `SingleKeyAccount` with ah underlying `Ed25519PrivateKey`.
 * The `legacy` argument needs to be explicitly set to false,
 * otherwise an `Ed25519Account` will be returned instead.
 */
interface GenerateEd25519SingleKeyAccountArgs {
    scheme?: SigningSchemeInput.Ed25519;
    legacy: false;
}
/**
 * Arguments for generating an `SingleKeyAccount` with any supported private key
 * that is not an `Ed25519PrivateKey`.
 * The `legacy` argument defaults to false and cannot be explicitly set to true.
 */
interface GenerateSingleKeyAccountArgs {
    scheme: Exclude<SigningSchemeInput, SigningSchemeInput.Ed25519>;
    legacy?: false;
}
/**
 * Arguments for generating an opaque `Account`.
 * This is used when the input signature scheme is not known at compilation time.
 */
interface GenerateAccountArgs {
    scheme?: SigningSchemeInput;
    legacy?: boolean;
}
/**
 * Arguments for deriving a private key from a mnemonic phrase and a BIP44 path.
 */
interface PrivateKeyFromDerivationPathArgs {
    path: string;
    mnemonic: string;
}
/**
 * Interface for a generic Aptos account.
 *
 * The interface is defined as abstract class to provide a single entrypoint for account generation,
 * either through `Account.generate()` or `Account.fromDerivationPath`.
 * Despite this being an abstract class, it should be treated as an interface and enforced using
 * the `implements` keyword.
 *
 * Note: Generating an account instance does not create the account on-chain.
 */
declare abstract class Account {
    /**
     * Public key associated with the account
     */
    abstract readonly publicKey: AccountPublicKey;
    /**
     * Account address associated with the account
     */
    abstract readonly accountAddress: AccountAddress;
    /**
     * Signing scheme used to sign transactions
     */
    abstract signingScheme: SigningScheme;
    /**
     * Derives an account from a randomly generated private key.
     * @param args.scheme The signature scheme to use, to generate the private key
     * @param args.legacy Whether to use a legacy authentication scheme, when applicable
     * @returns An account compatible with the provided signature scheme
     */
    static generate(args?: GenerateEd25519AccountArgs): Ed25519Account;
    static generate(args: GenerateEd25519SingleKeyAccountArgs): SingleKeyAccount;
    static generate(args: GenerateSingleKeyAccountArgs): SingleKeyAccount;
    static generate(args: GenerateAccountArgs): Account;
    /**
     * Creates an account from the provided private key.
     *
     * @param args.privateKey a valid private key
     * @param args.address the account's address. If not provided, it will be derived from the public key.
     * @param args.legacy Whether to use a legacy authentication scheme, when applicable
     */
    static fromPrivateKey(args: CreateEd25519AccountFromPrivateKeyArgs): Ed25519Account;
    static fromPrivateKey(args: CreateEd25519SingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;
    static fromPrivateKey(args: CreateSingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;
    static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): Account;
    /**
     * @deprecated use `fromPrivateKey` instead.
     * Instantiates an account given a private key and a specified account address.
     * This is primarily used to instantiate an `Account` that has had its authentication key rotated.
     *
     * @param args.privateKey PrivateKey - the underlying private key for the account
     * @param args.address AccountAddress - The account address the `Account` will sign for
     * @param args.legacy optional. If set to false, the keypair generated is a Unified keypair. Defaults
     * to generating a Legacy Ed25519 keypair
     *
     * @returns Account
     */
    static fromPrivateKeyAndAddress(args: CreateAccountFromPrivateKeyArgs): Account;
    /**
     * Derives an account with bip44 path and mnemonics
     *
     * @param args.scheme The signature scheme to derive the private key with
     * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,
     * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: GenerateEd25519AccountArgs & PrivateKeyFromDerivationPathArgs): Ed25519Account;
    static fromDerivationPath(args: GenerateEd25519SingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;
    static fromDerivationPath(args: GenerateSingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;
    static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs): Account;
    /**
     * @deprecated use `publicKey.authKey()` instead.
     * This key enables account owners to rotate their private key(s)
     * associated with the account without changing the address that hosts their account.
     * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}
     *
     * @param args.publicKey PublicKey - public key of the account
     * @returns The authentication key for the associated account
     */
    static authKey(args: {
        publicKey: AccountPublicKey;
    }): AuthenticationKey;
    /**
     * Sign a message using the available signing capabilities.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    abstract signWithAuthenticator(message: HexInput): AccountAuthenticator;
    /**
     * Sign a transaction using the available signing capabilities.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    abstract signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticator;
    /**
     * Sign the given message using the available signing capabilities.
     * @param message in HexInput format
     * @returns Signature
     */
    abstract sign(message: HexInput): Signature;
    /**
     * Sign the given transaction using the available signing capabilities.
     * @param transaction the transaction to be signed
     * @returns Signature
     */
    abstract signTransaction(transaction: AnyRawTransaction): Signature;
    /**
     * Verify the given message and signature with the public key.
     * @param args.message raw message data in HexInput format
     * @param args.signature signed message Signature
     * @returns
     */
    verifySignature(args: VerifySignatureArgs): boolean;
}

interface Ed25519SignerConstructorArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
}
interface Ed25519SignerFromDerivationPathArgs {
    path: string;
    mnemonic: string;
}
interface VerifyEd25519SignatureArgs {
    message: HexInput;
    signature: Ed25519Signature;
}
/**
 * Signer implementation for the Ed25519 authentication scheme.
 * This extends an {@link Ed25519Account} by adding signing capabilities through an {@link Ed25519PrivateKey}.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class Ed25519Account implements Account {
    /**
     * Private key associated with the account
     */
    readonly privateKey: Ed25519PrivateKey;
    readonly publicKey: Ed25519PublicKey;
    readonly accountAddress: AccountAddress;
    readonly signingScheme = SigningScheme.Ed25519;
    constructor(args: Ed25519SignerConstructorArgs);
    /**
     * Derives a signer from a randomly generated private key
     */
    static generate(): Ed25519Account;
    /**
     * Derives an account with bip44 path and mnemonics
     *
     * @param args.path the BIP44 derive hardened path e.g. m/44'/637'/0'/0'/0'
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: Ed25519SignerFromDerivationPathArgs): Ed25519Account;
    /**
     * Verify the given message and signature with the public key.
     *
     * @param args.message raw message data in HexInput format
     * @param args.signature signed message Signature
     * @returns
     */
    verifySignature(args: VerifyEd25519SignatureArgs): boolean;
    /**
     * Sign a message using the account's Ed25519 private key.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorEd25519;
    /**
     * Sign a transaction using the account's Ed25519 private key.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorEd25519;
    /**
     * Sign the given message using the account's Ed25519 private key.
     * @param message in HexInput format
     * @returns Signature
     */
    sign(message: HexInput): Ed25519Signature;
    /**
     * Sign the given transaction using the available signing capabilities.
     * @param transaction the transaction to be signed
     * @returns Signature
     */
    signTransaction(transaction: AnyRawTransaction): Ed25519Signature;
}

export { Account as A, type CreateEd25519AccountFromPrivateKeyArgs as C, type Ed25519SignerConstructorArgs as E, type GenerateEd25519AccountArgs as G, type PrivateKeyFromDerivationPathArgs as P, type SingleKeySignerConstructorArgs as S, type VerifyEd25519SignatureArgs as V, type Ed25519SignerFromDerivationPathArgs as a, Ed25519Account as b, type CreateEd25519SingleKeyAccountFromPrivateKeyArgs as c, type CreateSingleKeyAccountFromPrivateKeyArgs as d, type CreateAccountFromPrivateKeyArgs as e, type GenerateEd25519SingleKeyAccountArgs as f, type GenerateSingleKeyAccountArgs as g, type GenerateAccountArgs as h, type SingleKeySignerGenerateArgs as i, type SingleKeySignerFromDerivationPathArgs as j, type VerifySingleKeySignatureArgs as k, SingleKeyAccount as l };
