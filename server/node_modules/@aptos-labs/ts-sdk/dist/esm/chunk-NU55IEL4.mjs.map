{"version":3,"sources":["../../src/core/crypto/singleKey.ts"],"sourcesContent":["import { Deserializer, Serializer } from \"../../bcs\";\nimport { AnyPublicKeyVariant, AnySignatureVariant, SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Secp256k1PublicKey, Secp256k1Signature } from \"./secp256k1\";\nimport { KeylessPublicKey, KeylessSignature } from \"./keyless\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n */\nexport class AnyPublicKey extends AccountPublicKey {\n  /**\n   * Reference to the inner public key\n   */\n  public readonly publicKey: PublicKey;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  public readonly variant: AnyPublicKeyVariant;\n\n  // region Constructors\n\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n    if (publicKey instanceof Ed25519PublicKey) {\n      this.variant = AnyPublicKeyVariant.Ed25519;\n    } else if (publicKey instanceof Secp256k1PublicKey) {\n      this.variant = AnyPublicKeyVariant.Secp256k1;\n    } else if (publicKey instanceof KeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.Keyless;\n    } else {\n      throw new Error(\"Unsupported public key type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    if (!AnySignature.isInstance(signature)) {\n      return false;\n    }\n\n    return this.publicKey.verifySignature({\n      message,\n      signature: signature.signature,\n    });\n  }\n\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.SingleKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  toUint8Array() {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.publicKey.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let publicKey: PublicKey;\n    switch (variantIndex) {\n      case AnyPublicKeyVariant.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Secp256k1:\n        publicKey = Secp256k1PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Keyless:\n        publicKey = KeylessPublicKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);\n    }\n    return new AnyPublicKey(publicKey);\n  }\n\n  // endregion\n\n  /**\n   * @deprecated use `instanceof AnyPublicKey` instead.\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey {\n    return publicKey instanceof AnyPublicKey;\n  }\n\n  /**\n   * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.\n   */\n  isEd25519(): boolean {\n    return this.publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.\n   */\n  isSecp256k1PublicKey(): boolean {\n    return this.publicKey instanceof Secp256k1PublicKey;\n  }\n\n  static isInstance(publicKey: PublicKey): publicKey is AnyPublicKey {\n    return \"publicKey\" in publicKey && \"variant\" in publicKey;\n  }\n}\n\n/**\n * Instance of signature that uses the SingleKey authentication scheme.\n * This signature can only be generated by a `SingleKeySigner`, since it uses the\n * same authentication scheme.\n */\nexport class AnySignature extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: AnySignatureVariant;\n\n  // region Constructors\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n\n    if (signature instanceof Ed25519Signature) {\n      this.variant = AnySignatureVariant.Ed25519;\n    } else if (signature instanceof Secp256k1Signature) {\n      this.variant = AnySignatureVariant.Secp256k1;\n    } else if (signature instanceof KeylessSignature) {\n      this.variant = AnySignatureVariant.Keyless;\n    } else {\n      throw new Error(\"Unsupported signature type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountSignature\n\n  toUint8Array() {\n    // TODO: keep this warning around for a bit, and eventually change this to return `this.signature.toUint8Array()`.\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. \" +\n        \"Use AnySignature.bcsToBytes() instead.\",\n    );\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AnySignature {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let signature: Signature;\n    switch (variantIndex) {\n      case AnySignatureVariant.Ed25519:\n        signature = Ed25519Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Secp256k1:\n        signature = Secp256k1Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Keyless:\n        signature = KeylessSignature.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);\n    }\n    return new AnySignature(signature);\n  }\n\n  // endregion\n\n  static isInstance(signature: Signature): signature is AnySignature {\n    return (\n      \"signature\" in signature &&\n      typeof signature.signature === \"object\" &&\n      signature.signature !== null &&\n      \"toUint8Array\" in signature.signature\n    );\n  }\n}\n"],"mappings":"4PAiBO,IAAMA,EAAN,MAAMC,UAAqBC,CAAiB,CAajD,YAAYC,EAAsB,CAGhC,GAFA,MAAM,EACN,KAAK,UAAYA,EACbA,aAAqBC,EACvB,KAAK,QAAU,UACND,aAAqBE,EAC9B,KAAK,QAAU,UACNF,aAAqBG,EAC9B,KAAK,QAAU,MAEf,OAAM,IAAI,MAAM,6BAA6B,CAEjD,CAMA,gBAAgBC,EAAoC,CAClD,GAAM,CAAE,QAAAC,EAAS,UAAAC,CAAU,EAAIF,EAC/B,OAAKG,EAAa,WAAWD,CAAS,EAI/B,KAAK,UAAU,gBAAgB,CACpC,QAAAD,EACA,UAAWC,EAAU,SACvB,CAAC,EANQ,EAOX,CAEA,SAA6B,CAC3B,OAAOE,EAAkB,mBAAmB,CAC1C,SACA,MAAO,KAAK,aAAa,CAC3B,CAAC,CACH,CAEA,cAAe,CACb,OAAO,KAAK,WAAW,CACzB,CAMA,UAAUC,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,OAAO,EAC7C,KAAK,UAAU,UAAUA,CAAU,CACrC,CAEA,OAAO,YAAYC,EAA0C,CAC3D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDV,EACJ,OAAQW,EAAc,CACpB,OACEX,EAAYC,EAAiB,YAAYS,CAAY,EACrD,MACF,OACEV,EAAYE,EAAmB,YAAYQ,CAAY,EACvD,MACF,OACEV,EAAYG,EAAiB,YAAYO,CAAY,EACrD,MACF,QACE,MAAM,IAAI,MAAM,2CAA2CC,CAAY,EAAE,CAC7E,CACA,OAAO,IAAIb,EAAaE,CAAS,CACnC,CAOA,OAAO,YAAYA,EAAwD,CACzE,OAAOA,aAAqBF,CAC9B,CAKA,WAAqB,CACnB,OAAO,KAAK,qBAAqBG,CACnC,CAKA,sBAAgC,CAC9B,OAAO,KAAK,qBAAqBC,CACnC,CAEA,OAAO,WAAWF,EAAiD,CACjE,MAAO,cAAeA,GAAa,YAAaA,CAClD,CACF,EAOaO,EAAN,MAAMK,UAAqBC,CAAU,CAU1C,YAAYP,EAAsB,CAIhC,GAHA,MAAM,EACN,KAAK,UAAYA,EAEbA,aAAqBQ,EACvB,KAAK,QAAU,UACNR,aAAqBS,EAC9B,KAAK,QAAU,UACNT,aAAqBU,EAC9B,KAAK,QAAU,MAEf,OAAM,IAAI,MAAM,4BAA4B,CAEhD,CAMA,cAAe,CAGb,eAAQ,KACN,0IAEF,EACO,KAAK,WAAW,CACzB,CAMA,UAAUP,EAA8B,CACtCA,EAAW,sBAAsB,KAAK,OAAO,EAC7C,KAAK,UAAU,UAAUA,CAAU,CACrC,CAEA,OAAO,YAAYC,EAA0C,CAC3D,IAAMC,EAAeD,EAAa,wBAAwB,EACtDJ,EACJ,OAAQK,EAAc,CACpB,OACEL,EAAYQ,EAAiB,YAAYJ,CAAY,EACrD,MACF,OACEJ,EAAYS,EAAmB,YAAYL,CAAY,EACvD,MACF,OACEJ,EAAYU,EAAiB,YAAYN,CAAY,EACrD,MACF,QACE,MAAM,IAAI,MAAM,2CAA2CC,CAAY,EAAE,CAC7E,CACA,OAAO,IAAIC,EAAaN,CAAS,CACnC,CAIA,OAAO,WAAWA,EAAiD,CACjE,MACE,cAAeA,GACf,OAAOA,EAAU,WAAc,UAC/BA,EAAU,YAAc,MACxB,iBAAkBA,EAAU,SAEhC,CACF","names":["AnyPublicKey","_AnyPublicKey","AccountPublicKey","publicKey","Ed25519PublicKey","Secp256k1PublicKey","KeylessPublicKey","args","message","signature","AnySignature","AuthenticationKey","serializer","deserializer","variantIndex","_AnySignature","Signature","Ed25519Signature","Secp256k1Signature","KeylessSignature"]}