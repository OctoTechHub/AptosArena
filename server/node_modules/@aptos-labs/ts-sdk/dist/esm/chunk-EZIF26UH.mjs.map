{"version":3,"sources":["../../src/account/MultiKeyAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./Account\";\nimport { MultiKey, MultiKeySignature, PublicKey } from \"../core/crypto\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { KeylessAccount } from \"./KeylessAccount\";\n\nexport interface VerifyMultiKeySignatureArgs {\n  message: HexInput;\n  signature: MultiKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This accounts to use a M of N signing scheme. M and N are specified in the {@link MultiKey}\n * It signs messages via the array of M number of Accounts that individually correspond to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n */\nexport class MultiKeyAccount implements Account {\n  /**\n   * Public key associated with the account\n   */\n  readonly publicKey: MultiKey;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal or greater\n   * than this.publicKey.signaturesRequired\n   */\n  readonly signers: Account[];\n\n  /**\n   * An array of indicies where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   */\n  readonly signerIndicies: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  /**\n   * constructor for MultiKeyAccount\n   *\n   * @param args.multiKey the multikey of the account which consists of N public keys and a number M which is\n   * the number of required signatures.\n   * @param args.signers an array of M signers that will be used to sign the transaction\n   * @returns MultiKeyAccount\n   */\n  constructor(args: { multiKey: MultiKey; signers: Account[] }) {\n    const { multiKey, signers } = args;\n\n    this.publicKey = multiKey;\n    this.signingScheme = SigningScheme.MultiKey;\n\n    this.accountAddress = this.publicKey.authKey().derivedAddress();\n\n    // Get the index of each respective signer in the bitmap\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.publicKey));\n    }\n    // Zip signers and bit positions and sort signers by bit positions in order\n    // to ensure the signature is signed in ascending order according to the bitmap.\n    // Authentication on chain will fail otherwise.\n    const signersAndBitPosition: [Account, number][] = signers.map((signer, index) => [signer, bitPositions[index]]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndicies = signersAndBitPosition.map((value) => value[1]);\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  /**\n   * Static constructor for MultiKeyAccount\n   *\n   * @param args.publicKeys the N public keys of the MultiKeyAccount\n   * @param args.signaturesRequired the number of signatures required\n   * @param args.signers an array of M signers that will be used to sign the transaction\n   * @returns MultiKeyAccount\n   */\n  static fromPublicKeysAndSigners(args: {\n    publicKeys: PublicKey[];\n    signaturesRequired: number;\n    signers: Account[];\n  }): MultiKeyAccount {\n    const { publicKeys, signaturesRequired, signers } = args;\n    const multiKey = new MultiKey({ publicKeys, signaturesRequired });\n    return new MultiKeyAccount({ multiKey, signers });\n  }\n\n  static isMultiKeySigner(account: Account): account is MultiKeyAccount {\n    return account instanceof MultiKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Waits for any proofs on any KeylessAccount signers to be fetched. If the proof is fetched a syncronously, call this\n   * to ensure signing with the KeylessAccount does not fail as the proof must be ready.\n   * @return\n   */\n  async waitForProofFetch() {\n    const keylessSigners = this.signers.filter((signer) => signer instanceof KeylessAccount) as KeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param message in HexInput format\n   * @returns MultiKeySignature\n   */\n  sign(data: HexInput): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers\n   * @param transaction the transaction to be signed\n   * @returns MultiKeySignature\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signatures signed message MultiKeySignature\n   * @returns boolean\n   */\n  verifySignature(args: VerifyMultiKeySignatureArgs): boolean {\n    const { message, signature } = args;\n    const isSignerIndiciesSorted = this.signerIndicies.every(\n      (value, i) => i === 0 || value >= this.signerIndicies[i - 1],\n    );\n    if (!isSignerIndiciesSorted) {\n      return false;\n    }\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKey.publicKeys[this.signerIndicies[i]];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"kIAwBO,IAAMA,EAAN,MAAMC,CAAmC,CAuC9C,YAAYC,EAAkD,CAC5D,GAAM,CAAE,SAAAC,EAAU,QAAAC,CAAQ,EAAIF,EAE9B,KAAK,UAAYC,EACjB,KAAK,cAAgB,EAErB,KAAK,eAAiB,KAAK,UAAU,QAAQ,EAAE,eAAe,EAG9D,IAAME,EAAyB,CAAC,EAChC,QAAWC,KAAUF,EACnBC,EAAa,KAAK,KAAK,UAAU,SAASC,EAAO,SAAS,CAAC,EAK7D,IAAMC,EAA6CH,EAAQ,IAAI,CAACE,EAAQE,IAAU,CAACF,EAAQD,EAAaG,CAAK,CAAC,CAAC,EAC/GD,EAAsB,KAAK,CAACE,EAAGC,IAAMD,EAAE,CAAC,EAAIC,EAAE,CAAC,CAAC,EAChD,KAAK,QAAUH,EAAsB,IAAKI,GAAUA,EAAM,CAAC,CAAC,EAC5D,KAAK,eAAiBJ,EAAsB,IAAKI,GAAUA,EAAM,CAAC,CAAC,EACnE,KAAK,iBAAmB,KAAK,UAAU,aAAa,CAAE,KAAMN,CAAa,CAAC,CAC5E,CAUA,OAAO,yBAAyBH,EAIZ,CAClB,GAAM,CAAE,WAAAU,EAAY,mBAAAC,EAAoB,QAAAT,CAAQ,EAAIF,EAC9CC,EAAW,IAAIW,EAAS,CAAE,WAAAF,EAAY,mBAAAC,CAAmB,CAAC,EAChE,OAAO,IAAIZ,EAAgB,CAAE,SAAAE,EAAU,QAAAC,CAAQ,CAAC,CAClD,CAEA,OAAO,iBAAiBW,EAA8C,CACpE,OAAOA,aAAmBd,CAC5B,CAOA,sBAAsBe,EAAiD,CACrE,OAAO,IAAIC,EAA6B,KAAK,UAAW,KAAK,KAAKD,CAAO,CAAC,CAC5E,CAOA,iCAAiCE,EAA8D,CAC7F,OAAO,IAAID,EAA6B,KAAK,UAAW,KAAK,gBAAgBC,CAAW,CAAC,CAC3F,CAOA,MAAM,mBAAoB,CAExB,IAAMC,EADiB,KAAK,QAAQ,OAAQb,GAAWA,aAAkBc,CAAc,EACvD,IAAI,MAAOd,GAAWA,EAAO,kBAAkB,CAAC,EAChF,MAAM,QAAQ,IAAIa,CAAQ,CAC5B,CAOA,KAAKE,EAAmC,CACtC,IAAMC,EAAa,CAAC,EACpB,QAAWhB,KAAU,KAAK,QACxBgB,EAAW,KAAKhB,EAAO,KAAKe,CAAI,CAAC,EAEnC,OAAO,IAAIE,EAAkB,CAAE,WAAAD,EAAY,OAAQ,KAAK,gBAAiB,CAAC,CAC5E,CAOA,gBAAgBJ,EAAmD,CACjE,IAAMI,EAAa,CAAC,EACpB,QAAWhB,KAAU,KAAK,QACxBgB,EAAW,KAAKhB,EAAO,gBAAgBY,CAAW,CAAC,EAErD,OAAO,IAAIK,EAAkB,CAAE,WAAAD,EAAY,OAAQ,KAAK,gBAAiB,CAAC,CAC5E,CASA,gBAAgBpB,EAA4C,CAC1D,GAAM,CAAE,QAAAc,EAAS,UAAAQ,CAAU,EAAItB,EAI/B,GAAI,CAH2B,KAAK,eAAe,MACjD,CAACS,EAAOc,IAAMA,IAAM,GAAKd,GAAS,KAAK,eAAec,EAAI,CAAC,CAC7D,EAEE,MAAO,GAET,QAASA,EAAI,EAAGA,EAAID,EAAU,WAAW,OAAQC,GAAK,EAAG,CACvD,IAAMC,EAAkBF,EAAU,WAAWC,CAAC,EAE9C,GAAI,CADc,KAAK,UAAU,WAAW,KAAK,eAAeA,CAAC,CAAC,EACnD,gBAAgB,CAAE,QAAAT,EAAS,UAAWU,CAAgB,CAAC,EACpE,MAAO,EAEX,CACA,MAAO,EACT,CACF","names":["MultiKeyAccount","_MultiKeyAccount","args","multiKey","signers","bitPositions","signer","signersAndBitPosition","index","a","b","value","publicKeys","signaturesRequired","MultiKey","account","message","AccountAuthenticatorMultiKey","transaction","promises","KeylessAccount","data","signatures","MultiKeySignature","signature","i","singleSignature"]}