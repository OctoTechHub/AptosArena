{"version":3,"sources":["../../src/transactions/management/accountSequenceNumber.ts"],"sourcesContent":["/**\n * A wrapper that handles and manages an account sequence number.\n *\n * Submit up to `maximumInFlight` transactions per account in parallel with a timeout of `sleepTime`\n * If local assumes `maximumInFlight` are in flight, determine the actual committed state from the network\n * If there are less than `maximumInFlight` due to some being committed, adjust the window\n * If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating\n * If ever waiting more than `maxWaitTime` restart the sequence number to the current on-chain state\n *\n * Assumptions:\n * Accounts are expected to be managed by a single AccountSequenceNumber and not used otherwise.\n * They are initialized to the current on-chain state, so if there are already transactions in\n * flight, they may take some time to reset.\n * Accounts are automatically initialized if not explicitly\n *\n * Notes:\n * This is co-routine safe, that is many async tasks can be reading from this concurrently.\n * The state of an account cannot be used across multiple AccountSequenceNumber services.\n * The synchronize method will create a barrier that prevents additional nextSequenceNumber\n * calls until it is complete.\n * This only manages the distribution of sequence numbers it does not help handle transaction\n * failures.\n * If a transaction fails, you should call synchronize and wait for timeouts.\n */\n\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Account } from \"../../account\";\nimport { getInfo } from \"../../internal/account\";\nimport { nowInSeconds, sleep } from \"../../utils/helpers\";\n\nexport class AccountSequenceNumber {\n  readonly aptosConfig: AptosConfig;\n\n  readonly account: Account;\n\n  // sequence number on chain\n  lastUncommintedNumber: bigint | null = null;\n\n  // local sequence number\n  currentNumber: bigint | null = null;\n\n  /**\n   * We want to guarantee that we preserve ordering of workers to requests.\n   *\n   * `lock` is used to try to prevent multiple coroutines from accessing a shared resource at the same time,\n   * which can result in race conditions and data inconsistency.\n   * This code actually doesn't do it though, since we aren't giving out a slot, it is still somewhat a race condition.\n   *\n   * The ideal solution is likely that each thread grabs the next number from a incremental integer.\n   * When they complete, they increment that number and that entity is able to enter the `lock`.\n   * That would guarantee ordering.\n   */\n  lock = false;\n\n  maxWaitTime: number;\n\n  maximumInFlight: number;\n\n  sleepTime: number;\n\n  constructor(\n    aptosConfig: AptosConfig,\n    account: Account,\n    maxWaitTime: number,\n    maximumInFlight: number,\n    sleepTime: number,\n  ) {\n    this.aptosConfig = aptosConfig;\n    this.account = account;\n    this.maxWaitTime = maxWaitTime;\n    this.maximumInFlight = maximumInFlight;\n    this.sleepTime = sleepTime;\n  }\n\n  /**\n   * Returns the next available sequence number for this account\n   *\n   * @returns next available sequence number\n   */\n  async nextSequenceNumber(): Promise<bigint | null> {\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n    let nextNumber = BigInt(0);\n    try {\n      if (this.lastUncommintedNumber === null || this.currentNumber === null) {\n        await this.initialize();\n      }\n\n      if (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n        await this.update();\n\n        const startTime = nowInSeconds();\n        while (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n          await sleep(this.sleepTime);\n          if (nowInSeconds() - startTime > this.maxWaitTime) {\n            /* eslint-disable no-console */\n            console.warn(\n              `Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`,\n            );\n            await this.initialize();\n          } else {\n            await this.update();\n          }\n        }\n      }\n      nextNumber = this.currentNumber!;\n      this.currentNumber! += BigInt(1);\n    } catch (e) {\n      console.error(\"error in getting next sequence number for this account\", e);\n    } finally {\n      this.lock = false;\n    }\n    return nextNumber;\n  }\n\n  /**\n   * Initializes this account with the sequence number on chain\n   */\n  async initialize(): Promise<void> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.currentNumber = BigInt(sequenceNumber);\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n  }\n\n  /**\n   * Updates this account sequence number with the one on-chain\n   *\n   * @returns on-chain sequence number for this account\n   */\n  async update(): Promise<bigint> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n    return this.lastUncommintedNumber;\n  }\n\n  /**\n   * Synchronizes local sequence number with the seqeunce number on chain for this account.\n   *\n   * Poll the network until all submitted transactions have either been committed or until\n   * the maximum wait time has elapsed\n   */\n  async synchronize(): Promise<void> {\n    if (this.lastUncommintedNumber === this.currentNumber) return;\n\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n\n    try {\n      await this.update();\n      const startTime = nowInSeconds();\n      while (this.lastUncommintedNumber !== this.currentNumber) {\n        if (nowInSeconds() - startTime > this.maxWaitTime) {\n          /* eslint-disable no-console */\n          console.warn(\n            `Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`,\n          );\n          await this.initialize();\n        } else {\n          await sleep(this.sleepTime);\n          await this.update();\n        }\n      }\n    } catch (e) {\n      console.error(\"error in synchronizing this account sequence number with the one on chain\", e);\n    } finally {\n      this.lock = false;\n    }\n  }\n}\n"],"mappings":"yFA8BO,IAAMA,EAAN,KAA4B,CA8BjC,YACEC,EACAC,EACAC,EACAC,EACAC,EACA,CA9BF,2BAAuC,KAGvC,mBAA+B,KAa/B,UAAO,GAeL,KAAK,YAAcJ,EACnB,KAAK,QAAUC,EACf,KAAK,YAAcC,EACnB,KAAK,gBAAkBC,EACvB,KAAK,UAAYC,CACnB,CAOA,MAAM,oBAA6C,CAEjD,KAAO,KAAK,MACV,MAAMC,EAAM,KAAK,SAAS,EAG5B,KAAK,KAAO,GACZ,IAAIC,EAAa,OAAO,CAAC,EACzB,GAAI,CAKF,IAJI,KAAK,wBAA0B,MAAQ,KAAK,gBAAkB,OAChE,MAAM,KAAK,WAAW,EAGpB,KAAK,cAAiB,KAAK,uBAA0B,KAAK,gBAAiB,CAC7E,MAAM,KAAK,OAAO,EAElB,IAAMC,EAAYC,EAAa,EAC/B,KAAO,KAAK,cAAiB,KAAK,uBAA0B,KAAK,iBAC/D,MAAMH,EAAM,KAAK,SAAS,EACtBG,EAAa,EAAID,EAAY,KAAK,aAEpC,QAAQ,KACN,iEAAiE,KAAK,QAAQ,eAAe,SAAS,CAAC,EACzG,EACA,MAAM,KAAK,WAAW,GAEtB,MAAM,KAAK,OAAO,CAGxB,CACAD,EAAa,KAAK,cAClB,KAAK,eAAkB,OAAO,CAAC,CACjC,OAASG,EAAG,CACV,QAAQ,MAAM,yDAA0DA,CAAC,CAC3E,QAAE,CACA,KAAK,KAAO,EACd,CACA,OAAOH,CACT,CAKA,MAAM,YAA4B,CAChC,GAAM,CAAE,gBAAiBI,CAAe,EAAI,MAAMC,EAAQ,CACxD,YAAa,KAAK,YAClB,eAAgB,KAAK,QAAQ,cAC/B,CAAC,EACD,KAAK,cAAgB,OAAOD,CAAc,EAC1C,KAAK,sBAAwB,OAAOA,CAAc,CACpD,CAOA,MAAM,QAA0B,CAC9B,GAAM,CAAE,gBAAiBA,CAAe,EAAI,MAAMC,EAAQ,CACxD,YAAa,KAAK,YAClB,eAAgB,KAAK,QAAQ,cAC/B,CAAC,EACD,YAAK,sBAAwB,OAAOD,CAAc,EAC3C,KAAK,qBACd,CAQA,MAAM,aAA6B,CACjC,GAAI,KAAK,wBAA0B,KAAK,cAGxC,MAAO,KAAK,MACV,MAAML,EAAM,KAAK,SAAS,EAG5B,KAAK,KAAO,GAEZ,GAAI,CACF,MAAM,KAAK,OAAO,EAClB,IAAME,EAAYC,EAAa,EAC/B,KAAO,KAAK,wBAA0B,KAAK,eACrCA,EAAa,EAAID,EAAY,KAAK,aAEpC,QAAQ,KACN,iEAAiE,KAAK,QAAQ,eAAe,SAAS,CAAC,EACzG,EACA,MAAM,KAAK,WAAW,IAEtB,MAAMF,EAAM,KAAK,SAAS,EAC1B,MAAM,KAAK,OAAO,EAGxB,OAASI,EAAG,CACV,QAAQ,MAAM,4EAA6EA,CAAC,CAC9F,QAAE,CACA,KAAK,KAAO,EACd,EACF,CACF","names":["AccountSequenceNumber","aptosConfig","account","maxWaitTime","maximumInFlight","sleepTime","sleep","nextNumber","startTime","nowInSeconds","e","sequenceNumber","getInfo"]}