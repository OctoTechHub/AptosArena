{"version":3,"sources":["../../src/transactions/typeTag/parser.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  StructTag,\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagReference,\n  TypeTagSigner,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n  TypeTagVector,\n} from \".\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\n\n/**\n * Tells if the string is a valid Move identifier.  It can only be alphanumeric and `_`\n * @param str\n */\nfunction isValidIdentifier(str: string) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\n\n/**\n * Tells if the character is a whitespace character.  Does not work for multiple characters\n * @param char\n */\nfunction isValidWhitespaceCharacter(char: string) {\n  return !!char.match(/\\s/);\n}\n\n/**\n * Tells if a type is a generic type from the ABI, this will be of the form T0, T1, ...\n * @param str\n */\nfunction isGeneric(str: string) {\n  return !!str.match(/^T[0-9]+$/);\n}\n\n/**\n * Tells if a type is a reference type (starts with &)\n * @param str\n */\nfunction isRef(str: string) {\n  return !!str.match(/^&.+$/);\n}\n\n/**\n * Tells if a type is a primitive type\n * @param str\n */\nfunction isPrimitive(str: string) {\n  switch (str) {\n    case \"signer\":\n    case \"address\":\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Consumes all whitespace in a string, similar to trim\n * @param tagStr\n * @param pos\n */\nfunction consumeWhitespace(tagStr: string, pos: number) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      // If it's not colons, and it's an invalid character, we will stop here\n      break;\n    }\n  }\n  return i;\n}\n\n/**\n * State for TypeTag parsing.  This is pushed onto a stack to keep track of what is the current state\n */\ntype TypeTagState = {\n  savedExpectedTypes: number;\n  savedStr: string;\n  savedTypes: Array<TypeTag>;\n};\n\nexport enum TypeTagParserErrorType {\n  InvalidTypeTag = \"unknown type\",\n  UnexpectedGenericType = \"unexpected generic type\",\n  UnexpectedTypeArgumentClose = \"unexpected '>'\",\n  UnexpectedWhitespaceCharacter = \"unexpected whitespace character\",\n  UnexpectedComma = \"unexpected ','\",\n  TypeArgumentCountMismatch = \"type argument count doesn't match expected amount\",\n  MissingTypeArgumentClose = \"no matching '>' for '<'\",\n  MissingTypeArgument = \"no type argument before ','\",\n  UnexpectedPrimitiveTypeArguments = \"primitive types not expected to have type arguments\",\n  UnexpectedVectorTypeArgumentCount = \"vector type expected to have exactly one type argument\",\n  UnexpectedStructFormat = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\",\n  InvalidModuleNameCharacter = \"module name must only contain alphanumeric or '_' characters\",\n  InvalidStructNameCharacter = \"struct name must only contain alphanumeric or '_' characters\",\n  InvalidAddress = \"struct address must be valid\",\n}\n\nexport class TypeTagParserError extends Error {\n  constructor(typeTagStr: string, invalidReason: TypeTagParserErrorType) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n}\n\n/**\n * All types are made of a few parts they're either:\n * 1. A simple type e.g. u8\n * 2. A standalone struct e.g. 0x1::account::Account\n * 3. A nested struct e.g. 0x1::coin::Coin<0x1234::coin::MyCoin>\n *\n * There are a few more special cases that need to be handled, however.\n * 1. Multiple generics e.g 0x1::pair::Pair<u8, u16>\n * 2. Spacing in the generics e.g. 0x1::pair::Pair< u8 , u16>\n * 3. Nested generics of different depths e.g. 0x1::pair::Pair<0x1::coin::Coin<0x1234::coin::MyCoin>, u8>\n * 4. Generics for types in ABIs are filled in with placeholders e.g T1, T2, T3\n */\nexport function parseTypeTag(typeStr: string, options?: { allowGenerics?: boolean }) {\n  const allowGenerics = options?.allowGenerics ?? false;\n\n  const saved: Array<TypeTagState> = [];\n  // This represents the internal types for a type tag e.g. '0x1::coin::Coin<innerTypes>'\n  let innerTypes: Array<TypeTag> = [];\n  // This represents the current parsed types in a comma list e.g. 'u8, u8'\n  let curTypes: Array<TypeTag> = [];\n  // This represents the current character index\n  let cur: number = 0;\n  // This represents the current working string as a type or struct name\n  let currentStr: string = \"\";\n  let expectedTypes: number = 1;\n\n  // Iterate through each character, and handle the border conditions\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n\n    if (char === \"<\") {\n      // Start of a type argument, push current state onto a stack\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes,\n      });\n\n      // Clear current state\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      // Process last type, if there is no type string, then don't parse it\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n\n      // Pop off stack outer type, if there's nothing left, there were too many '>'\n      const savedPop = saved.pop();\n      if (savedPop === undefined) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedTypeArgumentClose);\n      }\n\n      // If the expected types don't match the number of commas, then we also fail\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.TypeArgumentCountMismatch);\n      }\n\n      // Add in the new created type, shifting the current types to the inner types\n      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      // Comma means we need to start parsing a new tag, push the previous one to the curTypes\n\n      // No top level commas (not in a type <> are allowed)\n      if (saved.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n      }\n      // If there was no actual value before the comma, then it's missing a type argument\n      if (currentStr.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgument);\n      }\n\n      // Process characters before as a type\n      const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n      // parse type tag and push it on the types\n      innerTypes = [];\n      curTypes.push(newType);\n      currentStr = \"\";\n      expectedTypes += 1;\n    } else if (isValidWhitespaceCharacter(char)) {\n      // This means we should save what we have and everything else should skip until the next\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n        // parse type tag and push it on the types\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n\n      // Skip ahead on any more whitespace\n      cur = consumeWhitespace(typeStr, cur);\n\n      // The next space MUST be a comma, or a closing > if there was something parsed before\n      // e.g. `u8 u8` is invalid but `u8, u8` is valid\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n      }\n\n      // eslint-disable-next-line no-continue\n      continue;\n    } else {\n      // Any other characters just append to the current string\n      currentStr += char;\n    }\n\n    cur += 1;\n  }\n\n  // This prevents a missing '>' on type arguments\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgumentClose);\n  }\n\n  // This prevents 'u8, u8' as an input\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n    default:\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n  }\n}\n\n/**\n * Parses a type tag with internal types associated\n * @param str\n * @param types\n * @param allowGenerics allow generic in parsing of the type tag\n */\nfunction parseTypeTagInner(str: string, types: Array<TypeTag>, allowGenerics: boolean): TypeTag {\n  const trimmedStr = str.trim();\n  const lowerCaseTrimmed = trimmedStr.toLowerCase();\n  if (isPrimitive(lowerCaseTrimmed)) {\n    if (types.length > 0) {\n      throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n    }\n  }\n\n  switch (trimmedStr.toLowerCase()) {\n    case \"signer\":\n      return new TypeTagSigner();\n    case \"bool\":\n      return new TypeTagBool();\n    case \"address\":\n      return new TypeTagAddress();\n    case \"u8\":\n      return new TypeTagU8();\n    case \"u16\":\n      return new TypeTagU16();\n    case \"u32\":\n      return new TypeTagU32();\n    case \"u64\":\n      return new TypeTagU64();\n    case \"u128\":\n      return new TypeTagU128();\n    case \"u256\":\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedVectorTypeArgumentCount);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      // Reference will have to handle the inner type\n      if (isRef(trimmedStr)) {\n        const actualType = trimmedStr.substring(1);\n        return new TypeTagReference(parseTypeTagInner(actualType, types, allowGenerics));\n      }\n\n      // Generics are always expected to be T0 or T1\n      if (isGeneric(trimmedStr)) {\n        if (allowGenerics) {\n          return new TypeTagGeneric(Number(trimmedStr.split(\"T\")[1]));\n        }\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedGenericType);\n      }\n\n      // If the value doesn't contain a colon, then we'll assume it isn't trying to be a struct\n      if (!trimmedStr.match(/:/)) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidTypeTag);\n      }\n\n      // Parse for a struct tag\n      // eslint-disable-next-line no-case-declarations\n      const structParts = trimmedStr.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedStructFormat);\n      }\n\n      // Validate struct address\n      // eslint-disable-next-line no-case-declarations\n      let address: AccountAddress;\n      try {\n        address = AccountAddress.fromString(structParts[0]);\n      } catch (error: any) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidAddress);\n      }\n\n      // Validate identifier characters\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidModuleNameCharacter);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidStructNameCharacter);\n      }\n\n      return new TypeTagStruct(\n        new StructTag(address, new Identifier(structParts[1]), new Identifier(structParts[2]), types),\n      );\n  }\n}\n"],"mappings":"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","names":["isValidIdentifier","str","isValidWhitespaceCharacter","char","isGeneric","isRef","isPrimitive","consumeWhitespace","tagStr","pos","i","innerChar","TypeTagParserErrorType","TypeTagParserError","typeTagStr","invalidReason","parseTypeTag","typeStr","options","allowGenerics","saved","innerTypes","curTypes","cur","currentStr","expectedTypes","newType","parseTypeTagInner","savedPop","savedStr","savedTypes","savedExpectedTypes","parsedTypeTag","nextChar","types","trimmedStr","lowerCaseTrimmed","TypeTagSigner","TypeTagBool","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","TypeTagVector","actualType","TypeTagReference","TypeTagGeneric","structParts","address","AccountAddress","TypeTagStruct","StructTag","Identifier"]}