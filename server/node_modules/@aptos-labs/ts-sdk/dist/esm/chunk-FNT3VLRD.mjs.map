{"version":3,"sources":["../../src/api/transactionSubmission/management.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { TransactionWorkerEvents, TransactionWorker, TransactionWorkerEventsEnum } from \"../../transactions/management\";\nimport { InputGenerateTransactionPayloadData, InputGenerateTransactionOptions } from \"../../transactions\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { Account } from \"../../account\";\n\nexport class TransactionManagement extends EventEmitter<TransactionWorkerEvents> {\n  account!: Account;\n\n  transactionWorker!: TransactionWorker;\n\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Internal function to start the transaction worker and\n   * listen to worker events\n   *\n   * @param args.sender The sender account to sign and submit the transaction\n   */\n  private start(args: { sender: Account }): void {\n    const { sender } = args;\n    this.account = sender;\n    this.transactionWorker = new TransactionWorker(this.config, sender);\n\n    this.transactionWorker.start();\n    this.registerToEvents();\n  }\n\n  /**\n   * Internal function to push transaction data to the transaction worker.\n   *\n   * @param args.data An array of transaction payloads\n   * @param args.options optional. Transaction generation configurations (excluding accountSequenceNumber)\n   *\n   * TODO - make this public once worker supports adding transactions to existing queue\n   */\n  private push(args: {\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    const { data, options } = args;\n\n    for (const d of data) {\n      this.transactionWorker.push(d, options);\n    }\n  }\n\n  /**\n   * Internal function to start listening to transaction worker events\n   *\n   * TODO - should we ask events to listen to as an input?\n   */\n  private registerToEvents() {\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSent, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSent, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSendFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSendFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecuted, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecuted, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecutionFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecutionFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.ExecutionFinish, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.ExecutionFinish, data);\n    });\n  }\n\n  /**\n   * Send batch transactions for a single account.\n   *\n   * This function uses a transaction worker that receives payloads to be processed\n   * and submitted to chain.\n   * Note that this process is best for submitting multiple transactions that\n   * dont rely on each other, i.e batch funds, batch token mints, etc.\n   *\n   * If any worker failure, the functions throws an error.\n   *\n   * @param args.sender The sender account to sign and submit the transaction\n   * @param args.data An array of transaction payloads\n   * @param args.options optional. Transaction generation configurations (excluding accountSequenceNumber)\n   *\n   * @return void. Throws if any error\n   */\n  forSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    try {\n      const { sender, data, options } = args;\n      this.start({ sender });\n\n      this.push({ data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n}\n"],"mappings":"yCAAA,OAAOA,MAAkB,gBAMlB,IAAMC,EAAN,cAAoCC,CAAsC,CAO/E,YAAYC,EAAqB,CAC/B,MAAM,EACN,KAAK,OAASA,CAChB,CAQQ,MAAMC,EAAiC,CAC7C,GAAM,CAAE,OAAAC,CAAO,EAAID,EACnB,KAAK,QAAUC,EACf,KAAK,kBAAoB,IAAIC,EAAkB,KAAK,OAAQD,CAAM,EAElE,KAAK,kBAAkB,MAAM,EAC7B,KAAK,iBAAiB,CACxB,CAUQ,KAAKD,EAGJ,CACP,GAAM,CAAE,KAAAG,EAAM,QAAAC,CAAQ,EAAIJ,EAE1B,QAAWK,KAAKF,EACd,KAAK,kBAAkB,KAAKE,EAAGD,CAAO,CAE1C,CAOQ,kBAAmB,CACzB,KAAK,kBAAkB,qBAAgD,MAAOD,GAAS,CACrF,KAAK,uBAAkDA,CAAI,CAC7D,CAAC,EACD,KAAK,kBAAkB,2BAAsD,MAAOA,GAAS,CAC3F,KAAK,6BAAwDA,CAAI,CACnE,CAAC,EACD,KAAK,kBAAkB,yBAAoD,MAAOA,GAAS,CACzF,KAAK,2BAAsDA,CAAI,CACjE,CAAC,EACD,KAAK,kBAAkB,gCAA2D,MAAOA,GAAS,CAChG,KAAK,kCAA6DA,CAAI,CACxE,CAAC,EACD,KAAK,kBAAkB,qBAAgD,MAAOA,GAAS,CACrF,KAAK,uBAAkDA,CAAI,CAC7D,CAAC,CACH,CAkBA,iBAAiBH,EAIR,CACP,GAAI,CACF,GAAM,CAAE,OAAAC,EAAQ,KAAAE,EAAM,QAAAC,CAAQ,EAAIJ,EAClC,KAAK,MAAM,CAAE,OAAAC,CAAO,CAAC,EAErB,KAAK,KAAK,CAAE,KAAAE,EAAM,QAAAC,CAAQ,CAAC,CAC7B,OAASE,EAAY,CACnB,MAAM,IAAI,MAAM,6CAA6CA,CAAK,EAAE,CACtE,CACF,CACF","names":["EventEmitter","TransactionManagement","EventEmitter","config","args","sender","TransactionWorker","data","options","d","error"]}