import { Deserializer } from '../bcs/deserializer.mjs';
import { Serializable, Serializer } from '../bcs/serializer.mjs';
import { HexInput, EphemeralPublicKeyVariant } from '../types/index.mjs';
import { PrivateKey } from '../core/crypto/privateKey.mjs';
import { EphemeralPublicKey, EphemeralSignature } from '../core/crypto/ephemeral.mjs';
import '../core/hex.mjs';
import '../core/common.mjs';
import '../utils/apiEndpoints.mjs';
import '../types/indexer.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../publicKey-B3XRNhHO.mjs';
import '../core/accountAddress.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../core/crypto/signature.mjs';

/**
 * A class which contains a key pair that is used in signing transactions via the Keyless authentication scheme. This key pair
 * is ephemeral and has an expiration time.  For more details on how this class is used -
 * https://aptos.dev/guides/keyless-accounts/#1-present-the-user-with-a-sign-in-with-idp-button-on-the-ui
 */
declare class EphemeralKeyPair extends Serializable {
    static readonly BLINDER_LENGTH: number;
    /**
     * A byte array of length BLINDER_LENGTH used to obfuscate the public key from the IdP.
     * Used in calculating the nonce passed to the IdP and as a secret witness in proof generation.
     */
    readonly blinder: Uint8Array;
    /**
     * A timestamp in seconds indicating when the ephemeral key pair is expired.  After expiry, a new
     * EphemeralKeyPair must be generated and a new JWT needs to be created.
     */
    readonly expiryDateSecs: number;
    /**
     * The value passed to the IdP when the user authenticates.  It comprises of a hash of the
     * ephermeral public key, expiry date, and blinder.
     */
    readonly nonce: string;
    /**
     * A private key used to sign transactions.  This private key is not tied to any account on the chain as it
     * is ephemeral (not permanent) in nature.
     */
    private privateKey;
    /**
     * A public key used to verify transactions.  This public key is not tied to any account on the chain as it
     * is ephemeral (not permanent) in nature.
     */
    private publicKey;
    constructor(args: {
        privateKey: PrivateKey;
        expiryDateSecs?: number;
        blinder?: HexInput;
    });
    /**
     * Returns the public key of the key pair.
     * @return EphemeralPublicKey
     */
    getPublicKey(): EphemeralPublicKey;
    /**
     * Returns the public key of the key pair.
     * @return boolean
     */
    isExpired(): boolean;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): EphemeralKeyPair;
    static fromBytes(bytes: Uint8Array): EphemeralKeyPair;
    /**
     * Returns the public key of the key pair.
     * @param scheme the type of keypair to use for the EphemeralKeyPair.  Only Ed25519 supported for now.
     * @param expiryDateSecs the date of expiry.
     * @return boolean
     */
    static generate(args?: {
        scheme?: EphemeralPublicKeyVariant;
        expiryDateSecs?: number;
    }): EphemeralKeyPair;
    /**
     * Sign the given message with the private key.
     * @param data in HexInput format
     * @returns EphemeralSignature
     */
    sign(data: HexInput): EphemeralSignature;
}

export { EphemeralKeyPair };
