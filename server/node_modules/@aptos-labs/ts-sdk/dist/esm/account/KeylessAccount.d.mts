import { SigningScheme, HexInput } from '../types/index.mjs';
import { AccountAddress } from '../core/accountAddress.mjs';
import { Deserializer } from '../bcs/deserializer.mjs';
import { Serializable, Serializer } from '../bcs/serializer.mjs';
import { KeylessPublicKey, ZeroKnowledgeSig, KeylessSignature } from '../core/crypto/keyless.mjs';
import { A as Account } from '../Ed25519Account-B1VMJOY2.mjs';
import { EphemeralKeyPair } from './EphemeralKeyPair.mjs';
import { AccountAuthenticatorSingleKey } from '../transactions/authenticator/account.mjs';
import { AnyRawTransaction } from '../transactions/types.mjs';
import '../utils/apiEndpoints.mjs';
import '../types/indexer.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../core/common.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../core/hex.mjs';
import '../publicKey-B3XRNhHO.mjs';
import '../core/crypto/signature.mjs';
import '../core/crypto/ephemeral.mjs';
import '../core/crypto/proof.mjs';
import '../types/keyless.mjs';
import '../api/aptosConfig.mjs';
import '../utils/const.mjs';
import '../core/crypto/ed25519.mjs';
import '../core/crypto/privateKey.mjs';
import '../core/crypto/singleKey.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../core/crypto/multiKey.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/simpleTransaction.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

/**
 * Account implementation for the Keyless authentication scheme.
 *
 * Used to represent a Keyless based account and sign transactions with it.
 *
 * Use KeylessAccount.fromJWTAndProof to instantiate a KeylessAccount with a JWT, proof and EphemeralKeyPair.
 *
 * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,
 * EphemeralKeyPair, and corresponding proof.
 */
declare class KeylessAccount extends Serializable implements Account {
    static readonly PEPPER_LENGTH: number;
    /**
     * The KeylessPublicKey associated with the account
     */
    readonly publicKey: KeylessPublicKey;
    /**
     * The EphemeralKeyPair used to generate sign.
     */
    readonly ephemeralKeyPair: EphemeralKeyPair;
    /**
     * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.
     */
    readonly uidKey: string;
    /**
     * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.
     */
    readonly uidVal: string;
    /**
     * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's
     * OIDC registration with the identity provider.
     */
    readonly aud: string;
    /**
     * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.
     */
    readonly pepper: Uint8Array;
    /**
     * Account address associated with the account
     */
    readonly accountAddress: AccountAddress;
    /**
     * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.
     */
    proof: ZeroKnowledgeSig | undefined;
    /**
     * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on
     * fetching the proof.
     */
    readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;
    /**
     * Signing scheme used to sign transactions
     */
    readonly signingScheme: SigningScheme;
    /**
     * The JWT token used to derive the account
     */
    readonly jwt: string;
    /**
     * An event emitter used to assist in handling asycronous proof fetching.
     */
    private readonly emitter;
    private constructor();
    /**
     * This initializes the asyncronous proof fetch
     * @return
     */
    init(promise: Promise<ZeroKnowledgeSig>): Promise<void>;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): KeylessAccount;
    /**
     * Checks if the proof is expired.  If so the account must be rederived with a new EphemeralKeyPair
     * and JWT token.
     * @return boolean
     */
    isExpired(): boolean;
    /**
     * Sign a message using Keyless.
     * @param message the message to sign, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey;
    /**
     * Sign a transaction using Keyless.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey;
    /**
     * Waits for asyncronous proof fetching to finish.
     * @return
     */
    waitForProofFetch(): Promise<void>;
    /**
     * Sign the given message using Keyless.
     * @param message in HexInput format
     * @returns Signature
     */
    sign(data: HexInput): KeylessSignature;
    /**
     * Sign the given transaction with Keyless.
     * Signs the transaction and proof to guard against proof malleability.
     * @param transaction the transaction to be signed
     * @returns KeylessSignature
     */
    signTransaction(transaction: AnyRawTransaction): KeylessSignature;
    /**
     * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount
     *
     * Verifies a signature given the message.
     *
     * TODO: Groth16 proof verification
     *
     * @param args.message the message that was signed.
     * @param args.signature the KeylessSignature to verify
     * @returns boolean
     */
    verifySignature(args: {
        message: HexInput;
        signature: KeylessSignature;
    }): boolean;
    static fromBytes(bytes: Uint8Array): KeylessAccount;
    static create(args: {
        address?: AccountAddress;
        proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;
        jwt: string;
        ephemeralKeyPair: EphemeralKeyPair;
        pepper: HexInput;
        uidKey?: string;
        proofFetchCallback?: ProofFetchCallback;
    }): KeylessAccount;
}
type ProofFetchSuccess = {
    status: "Success";
};
type ProofFetchFailure = {
    status: "Failed";
    error: string;
};
type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;
type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;
interface ProofFetchEvents {
    proofFetchFinish: (status: ProofFetchStatus) => void;
}

export { KeylessAccount, type ProofFetchCallback, type ProofFetchEvents, type ProofFetchFailure, type ProofFetchStatus, type ProofFetchSuccess };
