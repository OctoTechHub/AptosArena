import { A as Account } from '../Ed25519Account-B1VMJOY2.mjs';
import { HexInput, SigningScheme } from '../types/index.mjs';
import { AccountAddress } from '../core/accountAddress.mjs';
import { P as PublicKey } from '../publicKey-B3XRNhHO.mjs';
import { MultiKeySignature, MultiKey } from '../core/crypto/multiKey.mjs';
import { AccountAuthenticatorMultiKey } from '../transactions/authenticator/account.mjs';
import { AnyRawTransaction } from '../transactions/types.mjs';
import '../core/crypto/ed25519.mjs';
import '../bcs/deserializer.mjs';
import '../bcs/serializer.mjs';
import '../core/hex.mjs';
import '../core/common.mjs';
import '../core/crypto/privateKey.mjs';
import '../core/crypto/signature.mjs';
import '../core/crypto/singleKey.mjs';
import '../utils/apiEndpoints.mjs';
import '../types/indexer.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../api/aptosConfig.mjs';
import '../utils/const.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/simpleTransaction.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

interface VerifyMultiKeySignatureArgs {
    message: HexInput;
    signature: MultiKeySignature;
}
/**
 * Signer implementation for the MultiKey authentication scheme.
 *
 * This accounts to use a M of N signing scheme. M and N are specified in the {@link MultiKey}
 * It signs messages via the array of M number of Accounts that individually correspond to a public key in the {@link MultiKey}.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class MultiKeyAccount implements Account {
    /**
     * Public key associated with the account
     */
    readonly publicKey: MultiKey;
    /**
     * Account address associated with the account
     */
    readonly accountAddress: AccountAddress;
    /**
     * Signing scheme used to sign transactions
     */
    readonly signingScheme: SigningScheme;
    /**
     * The signers used to sign messages.  These signers should correspond to public keys in the
     * MultiKeyAccount's public key.  The number of signers should be equal or greater
     * than this.publicKey.signaturesRequired
     */
    readonly signers: Account[];
    /**
     * An array of indicies where for signer[i], signerIndicies[i] is the index of the corresponding public key in
     * publicKey.publicKeys.  Used to derive the right public key to use for verification.
     */
    readonly signerIndicies: number[];
    readonly signaturesBitmap: Uint8Array;
    /**
     * constructor for MultiKeyAccount
     *
     * @param args.multiKey the multikey of the account which consists of N public keys and a number M which is
     * the number of required signatures.
     * @param args.signers an array of M signers that will be used to sign the transaction
     * @returns MultiKeyAccount
     */
    constructor(args: {
        multiKey: MultiKey;
        signers: Account[];
    });
    /**
     * Static constructor for MultiKeyAccount
     *
     * @param args.publicKeys the N public keys of the MultiKeyAccount
     * @param args.signaturesRequired the number of signatures required
     * @param args.signers an array of M signers that will be used to sign the transaction
     * @returns MultiKeyAccount
     */
    static fromPublicKeysAndSigners(args: {
        publicKeys: PublicKey[];
        signaturesRequired: number;
        signers: Account[];
    }): MultiKeyAccount;
    static isMultiKeySigner(account: Account): account is MultiKeyAccount;
    /**
     * Sign a message using the account's signers.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey;
    /**
     * Sign a transaction using the account's signers.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey;
    /**
     * Waits for any proofs on any KeylessAccount signers to be fetched. If the proof is fetched a syncronously, call this
     * to ensure signing with the KeylessAccount does not fail as the proof must be ready.
     * @return
     */
    waitForProofFetch(): Promise<void>;
    /**
     * Sign the given message using the MultiKeyAccount's signers
     * @param message in HexInput format
     * @returns MultiKeySignature
     */
    sign(data: HexInput): MultiKeySignature;
    /**
     * Sign the given transaction using the MultiKeyAccount's signers
     * @param transaction the transaction to be signed
     * @returns MultiKeySignature
     */
    signTransaction(transaction: AnyRawTransaction): MultiKeySignature;
    /**
     * Verify the given message and signature with the public key.
     *
     * @param args.message raw message data in HexInput format
     * @param args.signatures signed message MultiKeySignature
     * @returns boolean
     */
    verifySignature(args: VerifyMultiKeySignatureArgs): boolean;
}

export { MultiKeyAccount, type VerifyMultiKeySignatureArgs };
