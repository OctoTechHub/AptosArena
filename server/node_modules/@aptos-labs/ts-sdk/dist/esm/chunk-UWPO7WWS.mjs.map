{"version":3,"sources":["../../src/core/crypto/multiEd25519.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AccountPublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents the public key of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519PublicKey extends AccountPublicKey {\n  /**\n   * Maximum number of public keys supported\n   */\n  static readonly MAX_KEYS = 32;\n\n  /**\n   * Minimum number of public keys needed\n   */\n  static readonly MIN_KEYS = 2;\n\n  /**\n   * Minimum threshold for the number of valid signatures required\n   */\n  static readonly MIN_THRESHOLD = 1;\n\n  /**\n   * List of Ed25519 public keys for this LegacyMultiEd25519PublicKey\n   */\n  public readonly publicKeys: Ed25519PublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   */\n  public readonly threshold: number;\n\n  /**\n   * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a\n   * transaction to be executed, at least K out of the N authorized signers have signed the transaction\n   * and passed the check conducted by the chain.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n   *\n   * @param args.publicKeys A list of public keys\n   * @param args.threshold At least \"threshold\" signatures must be valid\n   */\n  constructor(args: { publicKeys: Ed25519PublicKey[]; threshold: number }) {\n    super();\n    const { publicKeys, threshold } = args;\n\n    // Validate number of public keys\n    if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(\n        `Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ` +\n          `${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`,\n      );\n    }\n\n    // Validate threshold: must be between 1 and the number of public keys, inclusive\n    if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(\n        `Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`,\n      );\n    }\n\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n\n  // region AccountPublicKey\n\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    if (!(signature instanceof MultiEd25519Signature)) {\n      return false;\n    }\n\n    const indices: number[] = [];\n    for (let i = 0; i < 4; i += 1) {\n      for (let j = 0; j < 8; j += 1) {\n        // eslint-disable-next-line no-bitwise\n        const bitIsSet = (signature.bitmap[i] & (1 << (7 - j))) !== 0;\n        if (bitIsSet) {\n          const index = i * 8 + j;\n          indices.push(index);\n        }\n      }\n    }\n\n    if (indices.length !== signature.signatures.length) {\n      throw new Error(\"Bitmap and signatures length mismatch\");\n    }\n\n    if (indices.length < this.threshold) {\n      throw new Error(\"Not enough signatures\");\n    }\n\n    for (let i = 0; i < indices.length; i += 1) {\n      const publicKey = this.publicKeys[indices[i]];\n      if (!publicKey.verifySignature({ message, signature: signature.signatures[i] })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiEd25519,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k: Ed25519PublicKey, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n\n  // endregion\n}\n\n/**\n * Represents the signature of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519Signature extends Signature {\n  /**\n   * Maximum number of Ed25519 signatures supported\n   */\n  static MAX_SIGNATURES_SUPPORTED = 32;\n\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   */\n  public readonly signatures: Ed25519Signature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right.\n   * Alternatively, you can specify an array of bitmap positions.\n   * Valid position should range between 0 and 31.\n   * @see MultiEd25519Signature.createBitmap\n   */\n  constructor(args: { signatures: Ed25519Signature[]; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(\n        `The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`,\n      );\n    }\n    this.signatures = signatures;\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiEd25519Signature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiEd25519Signature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n  }\n\n  // region AccountSignature\n\n  /**\n   * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k: Ed25519Signature, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n\n    const signatures: Ed25519Signature[] = [];\n\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap });\n  }\n\n  // endregion\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, index) => {\n      if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      if (index > 0 && bit <= bits[index - 1]) {\n        throw new Error(\"The bits need to be sorted in ascending order.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n}\n"],"mappings":"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","names":["_MultiEd25519PublicKey","AccountPublicKey","args","publicKeys","threshold","message","signature","MultiEd25519Signature","indices","j","index","AuthenticationKey","bytes","Ed25519PublicKey","k","i","serializer","deserializer","keys","begin","MultiEd25519PublicKey","_MultiEd25519Signature","Signature","signatures","bitmap","Ed25519Signature","bits","firstBitInByte","dupCheckSet","bit","byteOffset","byte"]}