{"version":3,"sources":["../../src/internal/transactionSubmission.ts"],"sourcesContent":["/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { MoveVector, U8 } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account, KeylessAccount, MultiKeyAccount } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { PrivateKey } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { RotationProofChallenge } from \"../transactions/instances/rotationProofChallenge\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n} from \"../transactions/types\";\nimport { getInfo } from \"./account\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput, TransactionResponse } from \"../types\";\nimport { TypeTagU8, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK\n *\n * @param args.transaction AnyRawTransaction, as generated by `generateTransaction()`\n *\n * @return The message to be signed\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n *\n * @return The signer AccountAuthenticator\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signerPublicKey The signer public key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit transaction to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @return PendingTransactionResponse\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\nexport async function signAndSubmitTransaction(args: {\n  aptosConfig: AptosConfig;\n  signer: Account;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, transaction } = args;\n  // If the signer contains a KeylessAccount, await proof fetching in case the proof\n  // was fetched asyncronously.\n  if (signer instanceof KeylessAccount || signer instanceof MultiKeyAccount) {\n    await signer.waitForProofFetch();\n  }\n  const authenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * TODO: Need to refactor and move this function out of transactionSubmission\n */\nexport async function rotateAuthKey(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toNewPrivateKey: PrivateKey;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, fromAccount, toNewPrivateKey } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  const newAccount = Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n"],"mappings":"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","names":["generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","aptosConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessageForTransaction","signTransaction","signer","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","signAndSubmitTransaction","KeylessAccount","MultiKeyAccount","authenticator","packagePublishAbi","TypeTagVector","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","rotateAuthKeyAbi","TypeTagU8","rotateAuthKey","fromAccount","toNewPrivateKey","accountInfo","getInfo","newAccount","Account","challengeHex","RotationProofChallenge","proofSignedByCurrentPrivateKey","proofSignedByNewPrivateKey","rawTxn","U8"]}