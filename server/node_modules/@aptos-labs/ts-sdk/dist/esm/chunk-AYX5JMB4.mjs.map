{"version":3,"sources":["../../src/transactions/transactionBuilder/remoteAbi.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport {\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n} from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport {\n  EntryFunctionArgumentTypes,\n  SimpleEntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  ViewFunctionABI,\n  FunctionABI,\n  TypeArgument,\n} from \"../types\";\nimport { Bool, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isEmptyOption,\n  isString,\n  throwTypeMismatch,\n  convertNumber,\n} from \"./helpers\";\nimport { MoveFunction } from \"../../types\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeArgument>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: TypeArgument): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches a function ABI from the on-chain module ABI.  It doesn't validate whether it's a view or entry function.\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveFunction | undefined> {\n  // This fetch from the API is currently cached\n  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n\n  if (module.abi) {\n    return module.abi.exposed_functions.find((func) => func.name === functionName);\n  }\n\n  return undefined;\n}\n\n/**\n * Fetches the ABI for an entry function from the module\n *\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const numSigners = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = numSigners; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    signers: numSigners,\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for a view function from the module\n *\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchViewFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<ViewFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find view function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-view functions can't be used\n  if (!functionAbi.is_view) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(functionAbi.return[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary\n * @param functionName\n * @param functionAbi\n * @param arg\n * @param position\n * @param genericTypeParams\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbi: FunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // Ensure not too many arguments\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n\n  const param = functionAbi.parameters[position];\n  return checkOrConvertArgument(arg, param, position, genericTypeParams);\n}\n\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively\n * @param arg\n * @param param\n * @param position\n * @param genericTypeParams\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    if (isString(arg)) {\n      if (arg === \"true\") return new Bool(true);\n      if (arg === \"false\") return new Bool(false);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U8(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU16()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U16(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU32()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U32(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the sub-type\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 uint8array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams)));\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n\n    if (param.isOption()) {\n      if (isEmptyOption(arg)) {\n        // Here we attempt to reconstruct the underlying type\n        // Note, for some reason the `isBool` etc. does not work with the compiler\n        const innerParam = param.value.typeArgs[0];\n        if (innerParam instanceof TypeTagBool) {\n          return new MoveOption<Bool>(null);\n        }\n        if (innerParam instanceof TypeTagAddress) {\n          return new MoveOption<AccountAddress>(null);\n        }\n        if (innerParam instanceof TypeTagU8) {\n          return new MoveOption<U8>(null);\n        }\n        if (innerParam instanceof TypeTagU16) {\n          return new MoveOption<U16>(null);\n        }\n        if (innerParam instanceof TypeTagU32) {\n          return new MoveOption<U32>(null);\n        }\n        if (innerParam instanceof TypeTagU64) {\n          return new MoveOption<U64>(null);\n        }\n        if (innerParam instanceof TypeTagU128) {\n          return new MoveOption<U128>(null);\n        }\n        if (innerParam instanceof TypeTagU256) {\n          return new MoveOption<U256>(null);\n        }\n\n        // In all other cases, we will use a placeholder, it doesn't actually matter what the type is, but it will be obvious\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<MoveString>(null);\n      }\n\n      return new MoveOption(checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams));\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of an already BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n"],"mappings":"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","names":["TEXT_ENCODER","standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchFunctionAbi","moduleAddress","moduleName","functionName","aptosConfig","module","getModule","func","fetchEntryFunctionAbi","functionAbi","numSigners","findFirstNonSignerArg","params","i","fetchViewFunctionAbi","returnTypes","convertArgument","arg","position","genericTypeParams","param","checkOrConvertArgument","isEncodedEntryFunctionArgument","checkType","parseArg","isBool","Bool","throwTypeMismatch","AccountAddress","num","convertNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","MoveVector","item","MoveString","isEmptyOption","innerParam","TypeTagBool","MoveOption","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","isBcsBool","isBcsAddress","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","TypeTagStruct","isBcsString"]}