import{a as y}from"./chunk-RA3YPQG2.mjs";import{e as o}from"./chunk-Q67DUNMI.mjs";import{a as g,b as u}from"./chunk-6ERHGCK2.mjs";var l=class a{constructor(i){let{multiKey:s,signers:e}=i;this.publicKey=s,this.signingScheme=3,this.accountAddress=this.publicKey.authKey().derivedAddress();let r=[];for(let t of e)r.push(this.publicKey.getIndex(t.publicKey));let n=e.map((t,c)=>[t,r[c]]);n.sort((t,c)=>t[1]-c[1]),this.signers=n.map(t=>t[0]),this.signerIndicies=n.map(t=>t[1]),this.signaturesBitmap=this.publicKey.createBitmap({bits:r})}static fromPublicKeysAndSigners(i){let{publicKeys:s,signaturesRequired:e,signers:r}=i,n=new g({publicKeys:s,signaturesRequired:e});return new a({multiKey:n,signers:r})}static isMultiKeySigner(i){return i instanceof a}signWithAuthenticator(i){return new o(this.publicKey,this.sign(i))}signTransactionWithAuthenticator(i){return new o(this.publicKey,this.signTransaction(i))}async waitForProofFetch(){let s=this.signers.filter(e=>e instanceof y).map(async e=>e.waitForProofFetch());await Promise.all(s)}sign(i){let s=[];for(let e of this.signers)s.push(e.sign(i));return new u({signatures:s,bitmap:this.signaturesBitmap})}signTransaction(i){let s=[];for(let e of this.signers)s.push(e.signTransaction(i));return new u({signatures:s,bitmap:this.signaturesBitmap})}verifySignature(i){let{message:s,signature:e}=i;if(!this.signerIndicies.every((n,t)=>t===0||n>=this.signerIndicies[t-1]))return!1;for(let n=0;n<e.signatures.length;n+=1){let t=e.signatures[n];if(!this.publicKey.publicKeys[this.signerIndicies[n]].verifySignature({message:s,signature:t}))return!1}return!0}};export{l as a};
//# sourceMappingURL=chunk-EZIF26UH.mjs.map