import { a as AccountPublicKey, A as AuthenticationKey, P as PublicKey } from '../../publicKey-B3XRNhHO.mjs';
import { Signature } from './signature.mjs';
import { Deserializer } from '../../bcs/deserializer.mjs';
import { Serializer, Serializable } from '../../bcs/serializer.mjs';
import { HexInput, EphemeralCertificateVariant, ZkpVariant, LedgerVersionArg } from '../../types/index.mjs';
import { EphemeralPublicKey, EphemeralSignature } from './ephemeral.mjs';
import { Proof } from './proof.mjs';
import { Groth16VerificationKeyResponse } from '../../types/keyless.mjs';
import { AptosConfig } from '../../api/aptosConfig.mjs';
import '../accountAddress.mjs';
import '../common.mjs';
import '../../transactions/instances/transactionArgument.mjs';
import '../hex.mjs';
import '../../utils/apiEndpoints.mjs';
import '../../types/indexer.mjs';
import '../../types/generated/operations.mjs';
import '../../types/generated/types.mjs';
import '../../utils/const.mjs';

declare const EPK_HORIZON_SECS = 10000000;
declare const MAX_AUD_VAL_BYTES = 120;
declare const MAX_UID_KEY_BYTES = 30;
declare const MAX_UID_VAL_BYTES = 330;
declare const MAX_ISS_VAL_BYTES = 120;
declare const MAX_EXTRA_FIELD_BYTES = 350;
declare const MAX_JWT_HEADER_B64_BYTES = 300;
declare const MAX_COMMITED_EPK_BYTES = 93;
/**
 * Represents the KeylessPublicKey public key
 *
 * KeylessPublicKey authentication key is represented in the SDK as `AnyPublicKey`.
 */
declare class KeylessPublicKey extends AccountPublicKey {
    /**
     * The number of bytes that `idCommitment` should be
     */
    static readonly ID_COMMITMENT_LENGTH: number;
    /**
     * The value of the 'iss' claim on the JWT which identifies the OIDC provider.
     */
    readonly iss: string;
    /**
     * A value representing a cryptographic commitment to a user identity.
     *
     * It is calculated from the aud, uidKey, uidVal, pepper.
     */
    readonly idCommitment: Uint8Array;
    constructor(iss: string, idCommitment: HexInput);
    /**
     * Get the authentication key for the keyless public key
     *
     * @returns AuthenticationKey
     */
    authKey(): AuthenticationKey;
    /**
     * Get the public key in bytes (Uint8Array).
     *
     * @returns Uint8Array representation of the public key
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the public key as a hex string with the 0x prefix.
     *
     * @returns string representation of the public key
     */
    toString(): string;
    /**
     * Verifies a signed data with a public key
     *
     * @param args.message message
     * @param args.signature The signature
     * @returns true if the signature is valid
     */
    verifySignature(args: {
        message: HexInput;
        signature: KeylessSignature;
    }): boolean;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): KeylessPublicKey;
    static load(deserializer: Deserializer): KeylessPublicKey;
    static isPublicKey(publicKey: PublicKey): publicKey is KeylessPublicKey;
    /**
     * Creates a KeylessPublicKey from the JWT components plus pepper
     *
     * @param args.iss the iss of the identity
     * @param args.uidKey the key to use to get the uidVal in the JWT token
     * @param args.uidVal the value of the uidKey in the JWT token
     * @param args.aud the client ID of the application
     * @param args.pepper The pepper used to maintain privacy of the account
     * @returns KeylessPublicKey
     */
    static create(args: {
        iss: string;
        uidKey: string;
        uidVal: string;
        aud: string;
        pepper: HexInput;
    }): KeylessPublicKey;
    static fromJwtAndPepper(args: {
        jwt: string;
        pepper: HexInput;
        uidKey?: string;
    }): KeylessPublicKey;
    static isInstance(publicKey: PublicKey): boolean;
}
/**
 * A signature of a message signed via Keyless Accounnt that uses proofs or the jwt token to authenticate.
 */
declare class KeylessSignature extends Signature {
    /**
     * The inner signature ZeroKnowledgeSigniature or OpenIdSignature
     */
    readonly ephemeralCertificate: EphemeralCertificate;
    /**
     * The jwt header in the token used to create the proof/signature.  In json string representation.
     */
    readonly jwtHeader: string;
    /**
     * The expiry timestamp in seconds of the EphemeralKeyPair used to sign
     */
    readonly expiryDateSecs: number;
    /**
     * The ephemeral public key used to verify the signature
     */
    readonly ephemeralPublicKey: EphemeralPublicKey;
    /**
     * The signature resulting from signing with the private key of the EphemeralKeyPair
     */
    readonly ephemeralSignature: EphemeralSignature;
    constructor(args: {
        jwtHeader: string;
        ephemeralCertificate: EphemeralCertificate;
        expiryDateSecs: number;
        ephemeralPublicKey: EphemeralPublicKey;
        ephemeralSignature: EphemeralSignature;
    });
    /**
     * Get the signature in bytes (Uint8Array).
     *
     * @returns Uint8Array representation of the signature
     */
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): KeylessSignature;
    static getSimulationSignature(): KeylessSignature;
    static isSignature(signature: Signature): signature is KeylessSignature;
}
/**
 * A container for a signature that is a ZeroKnowledgeSig.  Can be expanded to support OpenIdSignature.
 */
declare class EphemeralCertificate extends Signature {
    readonly signature: Signature;
    /**
     * Index of the underlying enum variant
     */
    private readonly variant;
    constructor(signature: Signature, variant: EphemeralCertificateVariant);
    /**
     * Get the public key in bytes (Uint8Array).
     *
     * @returns Uint8Array representation of the public key
     */
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): EphemeralCertificate;
}
declare class G1Bytes extends Serializable {
    data: Uint8Array;
    constructor(data: HexInput);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): G1Bytes;
}
declare class G2Bytes extends Serializable {
    data: Uint8Array;
    constructor(data: HexInput);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): G2Bytes;
}
/**
 * A representation of a Groth16 proof.  The points are the compressed serialization of affine reprentation of the proof.
 */
declare class Groth16Zkp extends Proof {
    /**
     * The bytes of G1 proof point a
     */
    a: G1Bytes;
    /**
     * The bytes of G2 proof point b
     */
    b: G2Bytes;
    /**
     * The bytes of G1 proof point c
     */
    c: G1Bytes;
    constructor(args: {
        a: HexInput;
        b: HexInput;
        c: HexInput;
    });
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Groth16Zkp;
}
/**
 * A container for a different zero knowledge proof types
 */
declare class ZkProof extends Serializable {
    readonly proof: Proof;
    /**
     * Index of the underlying enum variant
     */
    private readonly variant;
    constructor(proof: Proof, variant: ZkpVariant);
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ZkProof;
}
/**
 * The signature representation of a proof
 */
declare class ZeroKnowledgeSig extends Signature {
    /**
     * The proof
     */
    readonly proof: ZkProof;
    /**
     * The max lifespan of the proof
     */
    readonly expHorizonSecs: number;
    /**
     * A key value pair on the JWT token that can be specified on the signature which would reveal the value on chain.
     * Can be used to assert identity or other attributes.
     */
    readonly extraField?: string;
    /**
     * The 'aud' value of the recovery service which is set when recovering an account.
     */
    readonly overrideAudVal?: string;
    /**
     * The training wheels signature
     */
    readonly trainingWheelsSignature?: EphemeralSignature;
    constructor(args: {
        proof: ZkProof;
        expHorizonSecs: number;
        extraField?: string;
        overrideAudVal?: string;
        trainingWheelsSignature?: EphemeralSignature;
    });
    /**
     * Get the signature in bytes (Uint8Array).
     *
     * @returns Uint8Array representation of the signature
     */
    toUint8Array(): Uint8Array;
    /**
     * Return a ZeroKnowledgeSig object from its bcs serialization in bytes.
     *
     * @returns ZeroKnowledgeSig
     */
    static fromBytes(bytes: Uint8Array): ZeroKnowledgeSig;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): ZeroKnowledgeSig;
}
/**
 * A class which represents the on-chain configuration for how Keyless accounts work
 */
declare class KeylessConfiguration {
    /**
     * The verification key used to verify Groth16 proofs on chain
     */
    readonly verficationKey: Groth16VerificationKey;
    /**
     * The maximum lifespan of an ephemeral key pair.  This is configured on chain.
     */
    readonly maxExpHorizonSecs: number;
    constructor(verficationKey: Groth16VerificationKey, maxExpHorizonSecs: number);
    static create(res: Groth16VerificationKeyResponse, maxExpHorizonSecs: number): KeylessConfiguration;
}
/**
 * A representation of the verification key stored on chain used to verify Groth16 proofs
 */
declare class Groth16VerificationKey {
    /**
     * The `alpha * G`, where `G` is the generator of G1
     */
    readonly alphaG1: G1Bytes;
    /**
     * The `alpha * H`, where `H` is the generator of G2
     */
    readonly betaG2: G2Bytes;
    /**
     * The `delta * H`, where `H` is the generator of G2
     */
    readonly deltaG2: G2Bytes;
    /**
     * The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where H is the generator of G1
     */
    readonly gammaAbcG1: G1Bytes[];
    /**
     * The `gamma * H`, where `H` is the generator of G2
     */
    readonly gammaG2: G2Bytes;
    constructor(args: {
        alphaG1: HexInput;
        betaG2: HexInput;
        deltaG2: HexInput;
        gammaAbcG1: [HexInput, HexInput];
        gammaG2: HexInput;
    });
    static fromGroth16VerificationKeyResponse(res: Groth16VerificationKeyResponse): Groth16VerificationKey;
}
/**
 * Gets the parameters of how Keyless Accounts are configured on chain including the verifying key and the max expiry horizon
 *
 * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version
 * @returns KeylessConfiguration
 */
declare function getKeylessConfig(args: {
    aptosConfig: AptosConfig;
    options?: LedgerVersionArg;
}): Promise<KeylessConfiguration>;

export { EPK_HORIZON_SECS, EphemeralCertificate, Groth16Zkp, KeylessConfiguration, KeylessPublicKey, KeylessSignature, MAX_AUD_VAL_BYTES, MAX_COMMITED_EPK_BYTES, MAX_EXTRA_FIELD_BYTES, MAX_ISS_VAL_BYTES, MAX_JWT_HEADER_B64_BYTES, MAX_UID_KEY_BYTES, MAX_UID_VAL_BYTES, ZeroKnowledgeSig, ZkProof, getKeylessConfig };
