import { Deserializer } from '../../bcs/deserializer.mjs';
import { Serializer, Serializable } from '../../bcs/serializer.mjs';
import { HexInput } from '../../types/index.mjs';
import { PrivateKey } from './privateKey.mjs';
import { P as PublicKey, V as VerifySignatureArgs } from '../../publicKey-B3XRNhHO.mjs';
import { Signature } from './signature.mjs';
import '../../utils/apiEndpoints.mjs';
import '../../types/indexer.mjs';
import '../../types/generated/operations.mjs';
import '../../types/generated/types.mjs';
import '../hex.mjs';
import '../common.mjs';
import '../accountAddress.mjs';
import '../../transactions/instances/transactionArgument.mjs';

/**
 * Represents the Secp256k1 ecdsa public key
 *
 * Secp256k1 authentication key is represented in the SDK as `AnyPublicKey`.
 */
declare class Secp256k1PublicKey extends PublicKey {
    static readonly LENGTH: number;
    private readonly key;
    /**
     * Create a new PublicKey instance from a Uint8Array or String.
     *
     * @param hexInput A HexInput (string or Uint8Array)
     */
    constructor(hexInput: HexInput);
    /**
     * Verifies a Secp256k1 signature against the public key
     *
     * Note signatures are validated to be canonical as a malleability check
     */
    verifySignature(args: VerifySignatureArgs): boolean;
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Secp256k1PublicKey;
    /**
     * @deprecated use `instanceof Secp256k1PublicKey` instead
     * @param publicKey
     */
    static isPublicKey(publicKey: PublicKey): publicKey is Secp256k1PublicKey;
    static isInstance(publicKey: PublicKey): publicKey is Secp256k1PublicKey;
}
/**
 * A Secp256k1 ecdsa private key
 */
declare class Secp256k1PrivateKey extends Serializable implements PrivateKey {
    /**
     * Length of Secp256k1 ecdsa private key
     */
    static readonly LENGTH: number;
    /**
     * The private key bytes
     * @private
     */
    private readonly key;
    /**
     * Create a new PrivateKey instance from a Uint8Array or String.
     *
     * @param hexInput A HexInput (string or Uint8Array)
     */
    constructor(hexInput: HexInput);
    /**
     * Generate a new random private key.
     *
     * @returns Secp256k1PrivateKey
     */
    static generate(): Secp256k1PrivateKey;
    /**
     * Derives a private key from a mnemonic seed phrase.
     *
     * @param path the BIP44 path
     * @param mnemonics the mnemonic seed phrase
     *
     * @returns The generated key
     */
    static fromDerivationPath(path: string, mnemonics: string): Secp256k1PrivateKey;
    /**
     * A private inner function so we can separate from the main fromDerivationPath() method
     * to add tests to verify we create the keys correctly.
     *
     * @param path the BIP44 path
     * @param seed the seed phrase created by the mnemonics
     *
     * @returns The generated key
     */
    private static fromDerivationPathInner;
    /**
     * Sign the given message with the private key.
     *
     * Note: signatures are canonical, and non-malleable
     *
     * @param message a message as a string or Uint8Array
     * @returns Signature
     */
    sign(message: HexInput): Secp256k1Signature;
    /**
     * Derive the Secp256k1PublicKey from this private key.
     *
     * @returns Secp256k1PublicKey
     */
    publicKey(): Secp256k1PublicKey;
    /**
     * Get the private key in bytes (Uint8Array).
     *
     * @returns
     */
    toUint8Array(): Uint8Array;
    /**
     * Get the private key as a hex string with the 0x prefix.
     *
     * @returns string representation of the private key
     */
    toString(): string;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Secp256k1PrivateKey;
    /**
     * @deprecated use `instanceof Secp256k1PrivateKey` instead
     */
    static isPrivateKey(privateKey: PrivateKey): privateKey is Secp256k1PrivateKey;
}
/**
 * A signature of a message signed using a Secp256k1 ecdsa private key
 */
declare class Secp256k1Signature extends Signature {
    /**
     * Secp256k1 ecdsa signatures are 256-bit.
     */
    static readonly LENGTH = 64;
    /**
     * The signature bytes
     * @private
     */
    private readonly data;
    /**
     * Create a new Signature instance from a Uint8Array or String.
     *
     * @param hexInput A HexInput (string or Uint8Array)
     */
    constructor(hexInput: HexInput);
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): Secp256k1Signature;
}

export { Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature };
