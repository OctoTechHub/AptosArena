import { Deserializer } from '../../bcs/deserializer.mjs';
import { Serializer } from '../../bcs/serializer.mjs';
import { a as AccountPublicKey, P as PublicKey, V as VerifySignatureArgs, A as AuthenticationKey } from '../../publicKey-B3XRNhHO.mjs';
import { Signature } from './signature.mjs';
import { AnyPublicKey, AnySignature } from './singleKey.mjs';
import '../../types/index.mjs';
import '../../utils/apiEndpoints.mjs';
import '../../types/indexer.mjs';
import '../../types/generated/operations.mjs';
import '../../types/generated/types.mjs';
import '../hex.mjs';
import '../common.mjs';
import '../accountAddress.mjs';
import '../../transactions/instances/transactionArgument.mjs';

/**
 * Represents the public key of a multi-agent account.
 *
 * The public keys of each individual agent can be any type of public key supported by Aptos.
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports
 * `Legacy` and `Unified` authentication keys.
 */
declare class MultiKey extends AccountPublicKey {
    /**
     * List of any public keys
     */
    readonly publicKeys: AnyPublicKey[];
    /**
     * The minimum number of valid signatures required, for the number of public keys specified
     */
    readonly signaturesRequired: number;
    constructor(args: {
        publicKeys: Array<PublicKey>;
        signaturesRequired: number;
    });
    verifySignature(args: VerifySignatureArgs): boolean;
    authKey(): AuthenticationKey;
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiKey;
    /**
     * Create a bitmap that holds the mapping from the original public keys
     * to the signatures passed in
     *
     * @param args.bits array of the index mapping to the matching public keys
     * @returns Uint8array bit map
     */
    createBitmap(args: {
        bits: number[];
    }): Uint8Array;
    /**
     * Get the index of the provided public key.
     *
     * @param publicKey array of the index mapping to the matching public keys
     * @returns the corresponding index of the publicKey, if it exists
     */
    getIndex(publicKey: PublicKey): number;
}
declare class MultiKeySignature extends Signature {
    /**
     * Number of bytes in the bitmap representing who signed the transaction (32-bits)
     */
    static BITMAP_LEN: number;
    /**
     * Maximum number of Ed25519 signatures supported
     */
    static MAX_SIGNATURES_SUPPORTED: number;
    /**
     * The list of underlying Ed25519 signatures
     */
    readonly signatures: AnySignature[];
    /**
     * 32-bit Bitmap representing who signed the transaction
     *
     * This is represented where each public key can be masked to determine whether the message was signed by that key.
     */
    readonly bitmap: Uint8Array;
    /**
     * Signature for a K-of-N multi-sig transaction.
     *
     * @see {@link
     * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}
     *
     * @param args.signatures A list of signatures
     * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
     * signature should be provided in `signatures`. Bits are read from left to right
     */
    constructor(args: {
        signatures: Array<Signature | AnySignature>;
        bitmap: Uint8Array | number[];
    });
    /**
     * Helper method to create a bitmap out of the specified bit positions
     * @param args.bits The bitmap positions that should be set. A position starts at index 0.
     * Valid position should range between 0 and 31.
     * @example
     * Here's an example of valid `bits`
     * ```
     * [0, 2, 31]
     * ```
     * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
     * The result bitmap should be 0b1010000000000000000000000000001
     *
     * @returns bitmap that is 32bit long
     */
    static createBitmap(args: {
        bits: number[];
    }): Uint8Array;
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): MultiKeySignature;
}

export { MultiKey, MultiKeySignature };
