{"version":3,"sources":["../../src/core/crypto/poseidon.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from \"poseidon-lite\";\n\nconst numInputsToPoseidonFunc = [\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n];\n\nconst BYTES_PACKED_PER_SCALAR = 31;\nconst MAX_NUM_INPUT_SCALARS = 16;\nconst MAX_NUM_INPUT_BYTES = (MAX_NUM_INPUT_SCALARS - 1) * BYTES_PACKED_PER_SCALAR;\n\n/**\n * Hashes a string to a field element via poseidon\n *\n * @returns bigint result of the hash\n */\nexport function hashStrToField(str: string, maxSizeBytes: number): bigint {\n  const textEncoder = new TextEncoder();\n  const strBytes = textEncoder.encode(str);\n  return hashBytesWithLen(strBytes, maxSizeBytes);\n}\n\nfunction hashBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Inputted bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const packed = padAndPackBytesWithLen(bytes, maxSizeBytes);\n  return poseidonHash(packed);\n}\n\nfunction padAndPackBytesNoLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const paddedStrBytes = padUint8ArrayWithZeros(bytes, maxSizeBytes);\n  return packBytes(paddedStrBytes);\n}\n\nexport function padAndPackBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  return padAndPackBytesNoLen(bytes, maxSizeBytes).concat([BigInt(bytes.length)]);\n}\n\nfunction packBytes(bytes: Uint8Array): bigint[] {\n  if (bytes.length > MAX_NUM_INPUT_BYTES) {\n    throw new Error(`Can't pack more than ${MAX_NUM_INPUT_BYTES}.  Was given ${bytes.length} bytes`);\n  }\n  return chunkUint8Array(bytes, BYTES_PACKED_PER_SCALAR).map((chunk) => bytesToBigIntLE(chunk));\n}\n\nfunction chunkUint8Array(array: Uint8Array, chunkSize: number): Uint8Array[] {\n  const result: Uint8Array[] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.subarray(i, i + chunkSize));\n  }\n  return result;\n}\n\nexport function bytesToBigIntLE(bytes: Uint8Array): bigint {\n  let result = BigInt(0);\n  for (let i = bytes.length - 1; i >= 0; i -= 1) {\n    result = (result << BigInt(8)) | BigInt(bytes[i]);\n  }\n  return result;\n}\n\nexport function bigIntToBytesLE(value: bigint, length: number): Uint8Array {\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; i += 1) {\n    bytes[i] = Number(value & BigInt(0xff));\n    // eslint-disable-next-line no-param-reassign\n    value >>= BigInt(8);\n  }\n  return bytes;\n}\n\nfunction padUint8ArrayWithZeros(inputArray: Uint8Array, paddedSize: number): Uint8Array {\n  if (paddedSize < inputArray.length) {\n    throw new Error(\"Padded size must be greater than or equal to the input array size.\");\n  }\n\n  // Create a new Uint8Array with the padded size\n  const paddedArray = new Uint8Array(paddedSize);\n\n  // Copy the content of the input array to the new array\n  paddedArray.set(inputArray);\n\n  // Fill the remaining space with zeros\n  for (let i = inputArray.length; i < paddedSize; i += 1) {\n    paddedArray[i] = 0;\n  }\n\n  return paddedArray;\n}\n\n/**\n * Hashes up to 16 scalar elements via the poseidon hashing algorithm.\n *\n * Each element must be scalar fields of the BN254 elliptic curve group.\n *\n * @returns bigint result of the hash\n */\nexport function poseidonHash(inputs: (number | bigint | string)[]): bigint {\n  if (inputs.length > numInputsToPoseidonFunc.length) {\n    throw new Error(\n      `Unable to hash input of length ${inputs.length}.  Max input length is ${numInputsToPoseidonFunc.length}`,\n    );\n  }\n  return numInputsToPoseidonFunc[inputs.length - 1](inputs);\n}\n"],"mappings":"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","names":["poseidon1","poseidon2","poseidon3","poseidon4","poseidon5","poseidon6","poseidon7","poseidon8","poseidon9","poseidon10","poseidon11","poseidon12","poseidon13","poseidon14","poseidon15","poseidon16","numInputsToPoseidonFunc","BYTES_PACKED_PER_SCALAR","MAX_NUM_INPUT_SCALARS","MAX_NUM_INPUT_BYTES","hashStrToField","str","maxSizeBytes","strBytes","hashBytesWithLen","bytes","packed","padAndPackBytesWithLen","poseidonHash","padAndPackBytesNoLen","paddedStrBytes","padUint8ArrayWithZeros","packBytes","chunkUint8Array","chunk","bytesToBigIntLE","array","chunkSize","result","i","bigIntToBytesLE","value","length","inputArray","paddedSize","paddedArray","inputs"]}