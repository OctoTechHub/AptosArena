{"version":3,"sources":["../../src/transactions/instances/transactionPayload.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { EntryFunctionBytes } from \"../../bcs/serializable/entryFunctionBytes\";\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"../../bcs/serializable/movePrimitives\";\nimport { MoveVector } from \"../../bcs/serializable/moveStructs\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { ModuleId } from \"./moduleId\";\nimport type { EntryFunctionArgument, ScriptFunctionArgument, TransactionArgument } from \"./transactionArgument\";\nimport { MoveModuleId, ScriptTransactionArgumentVariants, TransactionPayloadVariants } from \"../../types\";\nimport { TypeTag } from \"../typeTag\";\n\n/**\n * Deserialize a Script Transaction Argument\n */\nexport function deserializeFromScriptArgument(deserializer: Deserializer): TransactionArgument {\n  // index enum variant\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case ScriptTransactionArgumentVariants.U8:\n      return U8.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U64:\n      return U64.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U128:\n      return U128.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Address:\n      return AccountAddress.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U8Vector:\n      return MoveVector.deserialize(deserializer, U8);\n    case ScriptTransactionArgumentVariants.Bool:\n      return Bool.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U16:\n      return U16.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U32:\n      return U32.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U256:\n      return U256.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\n\n/**\n * Representation of the supported Transaction Payload\n * that can serialized and deserialized\n */\nexport abstract class TransactionPayload extends Serializable {\n  /**\n   * Serialize a Transaction Payload\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Transaction Payload\n   */\n  static deserialize(deserializer: Deserializer): TransactionPayload {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionPayloadVariants.Script:\n        return TransactionPayloadScript.load(deserializer);\n      case TransactionPayloadVariants.EntryFunction:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case TransactionPayloadVariants.Multisig:\n        return TransactionPayloadMultiSig.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n}\n\n/**\n * Representation of a Transaction Payload Script that can serialized and deserialized\n */\nexport class TransactionPayloadScript extends TransactionPayload {\n  public readonly script: Script;\n\n  constructor(script: Script) {\n    super();\n    this.script = script;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Script);\n    this.script.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadScript {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n}\n\n/**\n * Representation of a Transaction Payload Entry Function that can serialized and deserialized\n */\nexport class TransactionPayloadEntryFunction extends TransactionPayload {\n  public readonly entryFunction: EntryFunction;\n\n  constructor(entryFunction: EntryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.EntryFunction);\n    this.entryFunction.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadEntryFunction {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n}\n\n/**\n * Representation of a Transaction Payload Multi-sig that can serialized and deserialized\n */\nexport class TransactionPayloadMultiSig extends TransactionPayload {\n  public readonly multiSig: MultiSig;\n\n  constructor(multiSig: MultiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Multisig);\n    this.multiSig.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadMultiSig {\n    const value = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultiSig(value);\n  }\n}\n\n/**\n * Representation of a EntryFunction that can serialized and deserialized\n */\nexport class EntryFunction {\n  public readonly module_name: ModuleId;\n\n  public readonly function_name: Identifier;\n\n  public readonly type_args: Array<TypeTag>;\n\n  public readonly args: Array<EntryFunctionArgument>;\n\n  /**\n   * Contains the payload to run a function within a module.\n   * @param module_name Fully qualified module name in format \"account_address::module_name\" e.g. \"0x1::coin\"\n   * @param function_name The function name. e.g \"transfer\"\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   */\n  constructor(\n    module_name: ModuleId,\n    function_name: Identifier,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  /**\n   * A helper function to build a EntryFunction payload from raw primitive values\n   *\n   * @param module_id Fully qualified module name in format \"AccountAddress::module_id\" e.g. \"0x1::coin\"\n   * @param function_name Function name\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @param args Arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @returns EntryFunction\n   */\n  static build(\n    module_id: MoveModuleId,\n    function_name: string,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ): EntryFunction {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: EntryFunctionArgument) => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n\n  /**\n   * Deserializes an entry function payload with the arguments represented as EntryFunctionBytes instances.\n   * @see EntryFunctionBytes\n   *\n   * NOTE: When you deserialize an EntryFunction payload with this method, the entry function\n   * arguments are populated into the deserialized instance as type-agnostic, raw fixed bytes\n   * in the form of the EntryFunctionBytes class.\n   *\n   * In order to correctly deserialize these arguments as their actual type representations, you\n   * must know the types of the arguments beforehand and deserialize them yourself individually.\n   *\n   * One way you could achieve this is by using the ABIs for an entry function and deserializing each\n   * argument as its given, corresponding type.\n   *\n   * @param deserializer\n   * @returns A deserialized EntryFunction payload for a transaction.\n   *\n   */\n  static deserialize(deserializer: Deserializer): EntryFunction {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n\n    const length = deserializer.deserializeUleb128AsU32();\n    const args: Array<EntryFunctionArgument> = new Array<EntryFunctionBytes>();\n\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n}\n\n/**\n * Representation of a Script that can serialized and deserialized\n */\nexport class Script {\n  /**\n   * The move module bytecode\n   */\n  public readonly bytecode: Uint8Array;\n\n  /**\n   * The type arguments that the bytecode function requires.\n   */\n  public readonly type_args: Array<TypeTag>;\n\n  /**\n   * The arguments that the bytecode function requires.\n   */\n  public readonly args: Array<ScriptFunctionArgument>;\n\n  /**\n   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.\n   *\n   * @param bytecode The move module bytecode\n   * @param type_args The type arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @param args The arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   */\n  constructor(bytecode: Uint8Array, type_args: Array<TypeTag>, args: Array<ScriptFunctionArgument>) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: ScriptFunctionArgument) => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n\n  static deserialize(deserializer: Deserializer): Script {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array<ScriptFunctionArgument>();\n    for (let i = 0; i < length; i += 1) {\n      // Note that we deserialize directly to the Move value, not its Script argument representation.\n      // We are abstracting away the Script argument representation because knowing about it is\n      // functionally useless.\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n}\n\n/**\n * Representation of a MultiSig that can serialized and deserialized\n */\nexport class MultiSig {\n  public readonly multisig_address: AccountAddress;\n\n  public readonly transaction_payload?: MultiSigTransactionPayload;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param multisig_address The multi-sig account address the transaction will be executed as.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction. This is optional when executing a multi-sig\n   *  transaction whose payload is already stored on chain.\n   */\n  constructor(multisig_address: AccountAddress, transaction_payload?: MultiSigTransactionPayload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.multisig_address.serialize(serializer);\n    // Options are encoded with an extra u8 field before the value - 0x0 is none and 0x1 is present.\n    // We use serializeBool below to create this prefix value.\n    if (this.transaction_payload === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSig {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n}\n\n/**\n * Representation of a MultiSig Transaction Payload from `multisig_account.move`\n * that can be serialized and deserialized\n\n * This class exists right now to represent an extensible transaction payload class for\n * transactions used in `multisig_account.move`. Eventually, this class will be able to\n * support script payloads when the `multisig_account.move` module supports them.\n */\nexport class MultiSigTransactionPayload extends Serializable {\n  public readonly transaction_payload: EntryFunction;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction.\n   * This can only be EntryFunction for now but,\n   * Script might be supported in the future.\n   */\n  constructor(transaction_payload: EntryFunction) {\n    super();\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    /**\n     * We can support multiple types of inner transaction payload in the future.\n     * For now, it's only EntryFunction but if we support more types,\n     * we need to serialize with the right enum values here\n     */\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSigTransactionPayload {\n    // TODO: Support other types of payload beside EntryFunction.\n    // This is the enum value indicating which type of payload the multisig tx contains.\n    deserializer.deserializeUleb128AsU32();\n    return new MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n}\n"],"mappings":"kXAoBO,SAASA,EAA8BC,EAAiD,CAE7F,IAAMC,EAAQD,EAAa,wBAAwB,EACnD,OAAQC,EAAO,CACb,OACE,OAAOC,EAAG,YAAYF,CAAY,EACpC,OACE,OAAOG,EAAI,YAAYH,CAAY,EACrC,OACE,OAAOI,EAAK,YAAYJ,CAAY,EACtC,OACE,OAAOK,EAAe,YAAYL,CAAY,EAChD,OACE,OAAOM,EAAW,YAAYN,EAAcE,CAAE,EAChD,OACE,OAAOK,EAAK,YAAYP,CAAY,EACtC,OACE,OAAOQ,EAAI,YAAYR,CAAY,EACrC,OACE,OAAOS,EAAI,YAAYT,CAAY,EACrC,OACE,OAAOU,EAAK,YAAYV,CAAY,EACtC,QACE,MAAM,IAAI,MAAM,wDAAwDC,CAAK,EAAE,CACnF,CACF,CAMO,IAAeU,EAAf,cAA0CC,CAAa,CAS5D,OAAO,YAAYZ,EAAgD,CAEjE,IAAMC,EAAQD,EAAa,wBAAwB,EACnD,OAAQC,EAAO,CACb,OACE,OAAOY,EAAyB,KAAKb,CAAY,EACnD,OACE,OAAOc,EAAgC,KAAKd,CAAY,EAC1D,OACE,OAAOe,EAA2B,KAAKf,CAAY,EACrD,QACE,MAAM,IAAI,MAAM,iDAAiDC,CAAK,EAAE,CAC5E,CACF,CACF,EAKaY,EAAN,MAAMG,UAAiCL,CAAmB,CAG/D,YAAYM,EAAgB,CAC1B,MAAM,EACN,KAAK,OAASA,CAChB,CAEA,UAAUC,EAA8B,CACtCA,EAAW,uBAAuD,EAClE,KAAK,OAAO,UAAUA,CAAU,CAClC,CAEA,OAAO,KAAKlB,EAAsD,CAChE,IAAMiB,EAASE,EAAO,YAAYnB,CAAY,EAC9C,OAAO,IAAIgB,EAAyBC,CAAM,CAC5C,CACF,EAKaH,EAAN,MAAMM,UAAwCT,CAAmB,CAGtE,YAAYU,EAA8B,CACxC,MAAM,EACN,KAAK,cAAgBA,CACvB,CAEA,UAAUH,EAA8B,CACtCA,EAAW,uBAA8D,EACzE,KAAK,cAAc,UAAUA,CAAU,CACzC,CAEA,OAAO,KAAKlB,EAA6D,CACvE,IAAMqB,EAAgBC,EAAc,YAAYtB,CAAY,EAC5D,OAAO,IAAIoB,EAAgCC,CAAa,CAC1D,CACF,EAKaN,EAAN,MAAMQ,UAAmCZ,CAAmB,CAGjE,YAAYa,EAAoB,CAC9B,MAAM,EACN,KAAK,SAAWA,CAClB,CAEA,UAAUN,EAA8B,CACtCA,EAAW,uBAAyD,EACpE,KAAK,SAAS,UAAUA,CAAU,CACpC,CAEA,OAAO,KAAKlB,EAAwD,CAClE,IAAMyB,EAAQC,EAAS,YAAY1B,CAAY,EAC/C,OAAO,IAAIuB,EAA2BE,CAAK,CAC7C,CACF,EAKaH,EAAN,MAAMK,CAAc,CA4BzB,YACEC,EACAC,EACAC,EACAC,EACA,CACA,KAAK,YAAcH,EACnB,KAAK,cAAgBC,EACrB,KAAK,UAAYC,EACjB,KAAK,KAAOC,CACd,CAuBA,OAAO,MACLC,EACAH,EACAC,EACAC,EACe,CACf,OAAO,IAAIJ,EAAcM,EAAS,QAAQD,CAAS,EAAG,IAAIE,EAAWL,CAAa,EAAGC,EAAWC,CAAI,CACtG,CAEA,UAAUb,EAA8B,CACtC,KAAK,YAAY,UAAUA,CAAU,EACrC,KAAK,cAAc,UAAUA,CAAU,EACvCA,EAAW,gBAAyB,KAAK,SAAS,EAClDA,EAAW,sBAAsB,KAAK,KAAK,MAAM,EACjD,KAAK,KAAK,QAASiB,GAAgC,CACjDA,EAAK,0BAA0BjB,CAAU,CAC3C,CAAC,CACH,CAoBA,OAAO,YAAYlB,EAA2C,CAC5D,IAAM4B,EAAcK,EAAS,YAAYjC,CAAY,EAC/C6B,EAAgBK,EAAW,YAAYlC,CAAY,EACnD8B,EAAY9B,EAAa,kBAAkBoC,CAAO,EAElDC,EAASrC,EAAa,wBAAwB,EAC9C+B,EAAqC,IAAI,MAE/C,QAASO,EAAI,EAAGA,EAAID,EAAQC,GAAK,EAAG,CAClC,IAAMC,EAAmBvC,EAAa,wBAAwB,EACxDwC,EAAaC,EAAmB,YAAYzC,EAAcuC,CAAgB,EAChFR,EAAK,KAAKS,CAAU,CACtB,CAEA,OAAO,IAAIb,EAAcC,EAAaC,EAAeC,EAAWC,CAAI,CACtE,CACF,EAKaZ,EAAN,MAAMuB,CAAO,CAmClB,YAAYC,EAAsBb,EAA2BC,EAAqC,CAChG,KAAK,SAAWY,EAChB,KAAK,UAAYb,EACjB,KAAK,KAAOC,CACd,CAEA,UAAUb,EAA8B,CACtCA,EAAW,eAAe,KAAK,QAAQ,EACvCA,EAAW,gBAAyB,KAAK,SAAS,EAClDA,EAAW,sBAAsB,KAAK,KAAK,MAAM,EACjD,KAAK,KAAK,QAASiB,GAAiC,CAClDA,EAAK,2BAA2BjB,CAAU,CAC5C,CAAC,CACH,CAEA,OAAO,YAAYlB,EAAoC,CACrD,IAAM2C,EAAW3C,EAAa,iBAAiB,EACzC8B,EAAY9B,EAAa,kBAAkBoC,CAAO,EAClDC,EAASrC,EAAa,wBAAwB,EAC9C+B,EAAO,IAAI,MACjB,QAASO,EAAI,EAAGA,EAAID,EAAQC,GAAK,EAAG,CAIlC,IAAMM,EAAiB7C,EAA8BC,CAAY,EACjE+B,EAAK,KAAKa,CAAc,CAC1B,CACA,OAAO,IAAIF,EAAOC,EAAUb,EAAWC,CAAI,CAC7C,CACF,EAKaL,EAAN,MAAMmB,CAAS,CAapB,YAAYC,EAAkCC,EAAkD,CAC9F,KAAK,iBAAmBD,EACxB,KAAK,oBAAsBC,CAC7B,CAEA,UAAU7B,EAA8B,CACtC,KAAK,iBAAiB,UAAUA,CAAU,EAGtC,KAAK,sBAAwB,OAC/BA,EAAW,cAAc,EAAK,GAE9BA,EAAW,cAAc,EAAI,EAC7B,KAAK,oBAAoB,UAAUA,CAAU,EAEjD,CAEA,OAAO,YAAYlB,EAAsC,CACvD,IAAM8C,EAAmBzC,EAAe,YAAYL,CAAY,EAC1DgD,EAAiBhD,EAAa,gBAAgB,EAChD+C,EACJ,OAAIC,IACFD,EAAsBE,EAA2B,YAAYjD,CAAY,GAEpE,IAAI6C,EAASC,EAAkBC,CAAmB,CAC3D,CACF,EAUaE,EAAN,MAAMC,UAAmCtC,CAAa,CAU3D,YAAYmC,EAAoC,CAC9C,MAAM,EACN,KAAK,oBAAsBA,CAC7B,CAEA,UAAU7B,EAA8B,CAMtCA,EAAW,sBAAsB,CAAC,EAClC,KAAK,oBAAoB,UAAUA,CAAU,CAC/C,CAEA,OAAO,YAAYlB,EAAwD,CAGzE,OAAAA,EAAa,wBAAwB,EAC9B,IAAIkD,EAA2B5B,EAAc,YAAYtB,CAAY,CAAC,CAC/E,CACF","names":["deserializeFromScriptArgument","deserializer","index","U8","U64","U128","AccountAddress","MoveVector","Bool","U16","U32","U256","TransactionPayload","Serializable","TransactionPayloadScript","TransactionPayloadEntryFunction","TransactionPayloadMultiSig","_TransactionPayloadScript","script","serializer","Script","_TransactionPayloadEntryFunction","entryFunction","EntryFunction","_TransactionPayloadMultiSig","multiSig","value","MultiSig","_EntryFunction","module_name","function_name","type_args","args","module_id","ModuleId","Identifier","item","TypeTag","length","i","fixedBytesLength","fixedBytes","EntryFunctionBytes","_Script","bytecode","scriptArgument","_MultiSig","multisig_address","transaction_payload","payloadPresent","MultiSigTransactionPayload","_MultiSigTransactionPayload"]}