{"version":3,"sources":["../../src/core/hex.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { HexInput } from \"../types\";\n\n/**\n * This enum is used to explain why parsing might have failed.\n */\nexport enum HexInvalidReason {\n  TOO_SHORT = \"too_short\",\n  INVALID_LENGTH = \"invalid_length\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n}\n\n/**\n * NOTE: Do not use this class when working with account addresses, use AccountAddress.\n *\n * NOTE: When accepting hex data as input to a function, prefer to accept HexInput and\n * then use the static helper methods of this class to convert it into the desired\n * format. This enables the greatest flexibility for the developer.\n *\n * Hex is a helper class for working with hex data. Hex data, when represented as a\n * string, generally looks like this, for example: 0xaabbcc, 45cd32, etc.\n *\n * You might use this class like this:\n *\n * ```ts\n * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {\n *   const txnHashString = Hex.fromHexInput(txnHash).toString();\n *   return await getTransactionByHashInner(txnHashString);\n * }\n * ```\n *\n * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string\n * with a leading 0x prefix, regardless of what the input format was.\n *\n * These are some other ways to chain the functions together:\n * - `Hex.fromHexString({ hexInput: \"0x1f\" }).toUint8Array()`\n * - `new Hex([1, 3]).toStringWithoutPrefix()`\n */\nexport class Hex {\n  private readonly data: Uint8Array;\n\n  /**\n   * Create a new Hex instance from a Uint8Array.\n   *\n   * @param data Uint8Array\n   */\n  constructor(data: Uint8Array) {\n    this.data = data;\n  }\n\n  // ===\n  // Methods for representing an instance of Hex as other types.\n  // ===\n\n  /**\n   * Get the inner hex data. The inner data is already a Uint8Array so no conversion\n   * is taking place here, it just returns the inner data.\n   *\n   * @returns Hex data as Uint8Array\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Get the hex data as a string without the 0x prefix.\n   *\n   * @returns Hex string without 0x prefix\n   */\n  toStringWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the hex data as a string with the 0x prefix.\n   *\n   * @returns Hex string with 0x prefix\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  // ===\n  // Methods for creating an instance of Hex from other types.\n  // ===\n\n  /**\n   * Static method to convert a hex string to Hex\n   *\n   * @param str A hex string, with or without the 0x prefix\n   *\n   * @returns Hex\n   */\n  static fromHexString(str: string): Hex {\n    let input = str;\n\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n\n    if (input.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\",\n        HexInvalidReason.TOO_SHORT,\n      );\n    }\n\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", HexInvalidReason.INVALID_LENGTH);\n    }\n\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (error: any) {\n      throw new ParsingError(\n        `Hex string contains invalid hex characters: ${error?.message}`,\n        HexInvalidReason.INVALID_HEX_CHARS,\n      );\n    }\n  }\n\n  /**\n   * Static method to convert an instance of HexInput to Hex\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   *\n   * @returns Hex\n   */\n  static fromHexInput(hexInput: HexInput): Hex {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromHexString(hexInput);\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the string is valid hex.\n   *\n   * @param str A hex string representing byte data.\n   *\n   * @returns valid = true if the string is valid, false if not. If the string is not\n   * valid, invalidReason and invalidReasonMessage will be set explaining why it is\n   * invalid.\n   */\n  static isValid(str: string): ParsingResult<HexInvalidReason> {\n    try {\n      Hex.fromHexString(str);\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Return whether Hex instances are equal. Hex instances are considered equal if\n   * their underlying byte data is identical.\n   *\n   * @param other The Hex instance to compare to.\n   * @returns true if the Hex instances are equal, false if not.\n   */\n  equals(other: Hex): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n"],"mappings":"oCAGA,OAAS,cAAAA,EAAY,cAAAC,MAAkB,sBAOhC,IAAKC,OACVA,EAAA,UAAY,YACZA,EAAA,eAAiB,iBACjBA,EAAA,kBAAoB,oBAHVA,OAAA,IAgCCC,EAAN,MAAMC,CAAI,CAQf,YAAYC,EAAkB,CAC5B,KAAK,KAAOA,CACd,CAYA,cAA2B,CACzB,OAAO,KAAK,IACd,CAOA,uBAAgC,CAC9B,OAAOC,EAAW,KAAK,IAAI,CAC7B,CAOA,UAAmB,CACjB,MAAO,KAAK,KAAK,sBAAsB,CAAC,EAC1C,CAaA,OAAO,cAAcC,EAAkB,CACrC,IAAIC,EAAQD,EAMZ,GAJIC,EAAM,WAAW,IAAI,IACvBA,EAAQA,EAAM,MAAM,CAAC,GAGnBA,EAAM,SAAW,EACnB,MAAM,IAAIC,EACR,4FACA,WACF,EAGF,GAAID,EAAM,OAAS,IAAM,EACvB,MAAM,IAAIC,EAAa,uDAAwD,gBAA+B,EAGhH,GAAI,CACF,OAAO,IAAIL,EAAIM,EAAWF,CAAK,CAAC,CAClC,OAASG,EAAY,CACnB,MAAM,IAAIF,EACR,+CAA+CE,GAAO,OAAO,GAC7D,mBACF,CACF,CACF,CASA,OAAO,aAAaC,EAAyB,CAC3C,OAAIA,aAAoB,WAAmB,IAAIR,EAAIQ,CAAQ,EACpDR,EAAI,cAAcQ,CAAQ,CACnC,CAeA,OAAO,QAAQL,EAA8C,CAC3D,GAAI,CACF,OAAAH,EAAI,cAAcG,CAAG,EACd,CAAE,MAAO,EAAK,CACvB,OAASI,EAAY,CACnB,MAAO,CACL,MAAO,GACP,cAAeA,GAAO,cACtB,qBAAsBA,GAAO,OAC/B,CACF,CACF,CASA,OAAOE,EAAqB,CAC1B,OAAI,KAAK,KAAK,SAAWA,EAAM,KAAK,OAAe,GAC5C,KAAK,KAAK,MAAM,CAACC,EAAOC,IAAUD,IAAUD,EAAM,KAAKE,CAAK,CAAC,CACtE,CACF","names":["bytesToHex","hexToBytes","HexInvalidReason","Hex","_Hex","data","bytesToHex","str","input","ParsingError","hexToBytes","error","hexInput","other","value","index"]}