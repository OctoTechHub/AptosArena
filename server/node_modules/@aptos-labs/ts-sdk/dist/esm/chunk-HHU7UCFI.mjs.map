{"version":3,"sources":["../../src/internal/account.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AptosApiError, getAptosFullNode, paginateWithCursor } from \"../client\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\n\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  const { aptosConfig, accountAddress } = args;\n  const { data } = await getAptosFullNode<{}, AccountData>({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}`,\n  });\n  return data;\n}\n\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Queries for a move module given account address and module name\n *\n * @param args.accountAddress Hex-encoded 32 byte Aptos account address\n * @param args.moduleName The name of the module\n * @param args.query.ledgerVersion Specifies ledger version of transactions. By default, latest version will be used\n * @returns The move module.\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\nasync function getModuleInner(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  const { aptosConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getAptosFullNode<{}, MoveModuleBytecode>({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n  let coinAssetType: string | undefined;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    coinAssetType = coinType;\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (args.coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    // TODO: add a view function lookup for non-APT migrated coins\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * NOTE: There is a potential issue once unified single signer scheme will be adopted\n * by the community.\n *\n * Becuase on could create 2 accounts with the same private key with this new authenticator type,\n * weâll need to determine the order in which we lookup the accounts. First unified\n * scheme and then legacy scheme vs first legacy scheme and then unified scheme.\n *\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n"],"mappings":"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","names":["getInfo","args","aptosConfig","accountAddress","data","getAptosFullNode","AccountAddress","getModules","options","paginateWithCursor","getModule","getModuleInner","memoizeAsync","moduleName","getTransactions","getResources","getResource","resourceType","lookupOriginalAccountAddress","authenticationKey","resource","handle","authKeyAddress","originalAddress","getTableItem","err","AptosApiError","getAccountTokensCount","whereCondition","queryIndexer","GetAccountTokensCount","getAccountOwnedTokens","graphqlQuery","GetAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","GetAccountOwnedTokensFromCollection","getAccountCollectionsWithOwnedTokens","GetAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","address","GetAccountTransactionsCount","getAccountCoinAmount","coinType","faMetadataAddress","coinAssetType","faAddress","APTOS_COIN","createObjectAddress","addr","where","getAccountCoinsData","GetAccountCoinsData","getAccountCoinsCount","GetAccountCoinsCount","getAccountOwnedObjects","GetObjectData","deriveAccountFromPrivateKey","privateKey","publicKey","AnyPublicKey","Secp256k1PrivateKey","AuthenticationKey","Account","Ed25519PrivateKey","singleSenderTransactionAuthenticatorAuthKey","isAccountExist","legacyAuthKey","authKey","error"]}